<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ODCV Analytics Dashboard - Interactive Tour</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f0f2f5;
            color: #1c1e21;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #1e3a5f 0%, #2d5a8e 100%);
            color: white;
            padding: 28px 36px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .header h1 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .header-subtitle {
            font-size: 16px;
            opacity: 0.9;
        }

        .load-db-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
        }

        .load-db-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
        }

        .load-db-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Executive Dashboard */
        .executive-dashboard {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 16px;
            margin: 28px 36px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }

        .dashboard-title {
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
            text-align: center;
        }

        .analysis-period {
            text-align: center;
            font-size: 0.9em;
            color: #666;
            margin-bottom: 20px;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 15px;
        }

        .dashboard-metric {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            text-align: center;
        }

        .metric-title {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .metric-value {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metric-subtitle {
            font-size: 0.8em;
            color: #666;
        }

        .help-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #6c757d;
            color: white;
            font-size: 12px;
            font-weight: bold;
            font-style: normal;
            text-align: center;
            line-height: 18px;
            cursor: help;
            margin-left: 8px;
            position: relative;
        }

        .help-icon:hover {
            background: #495057;
        }

        .tooltip-content {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            top: -10px;
            left: 25px;
            background: #333;
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 0.85em;
            white-space: nowrap;
            z-index: 1000;
            transition: opacity 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            min-width: 300px;
        }

        .tooltip-content::before {
            content: "";
            position: absolute;
            top: 15px;
            left: -5px;
            border: 5px solid transparent;
            border-right-color: #333;
        }

        .help-icon:hover .tooltip-content {
            visibility: visible;
            opacity: 1;
        }

        /* Main Content Area */
        .main-content {
            margin: 28px 36px;
        }

        /* Controls */
        .controls {
            background: white;
            padding: 24px;
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .controls-title {
            font-size: 20px;
            font-weight: 600;
            color: #1e3a5f;
        }

        .group-toggle {
            display: flex;
            gap: 8px;
            background: #f8f9fa;
            padding: 4px;
            border-radius: 8px;
        }

        .toggle-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.2s;
        }

        .toggle-btn.active {
            background: white;
            color: #1e3a5f;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .filter-grid {
            display: flex;
            justify-content: flex-start;
        }

        .time-period-toggle {
            display: flex;
            gap: 8px;
            background: #f8f9fa;
            padding: 4px;
            border-radius: 8px;
        }

        .time-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.2s;
        }

        .time-btn.active {
            background: white;
            color: #1e3a5f;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Upload Section */
        .upload-section {
            background: white;
            padding: 24px;
            border-radius: 12px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .upload-area {
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
        }

        .upload-area.dragover {
            border-color: #007bff;
            background: #f8f9ff;
        }

        .upload-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin: 10px;
        }

        .generate-test-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin: 10px;
        }

        /* Rest of styles from dashboard_variant3 */
        .grouped-container {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .group-header {
            background: linear-gradient(90deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 16px 24px;
            border-left: 4px solid #007bff;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .group-header:hover {
            background: linear-gradient(90deg, #e9ecef 0%, #dee2e6 100%);
        }

        .group-info {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .group-toggle-icon {
            font-size: 18px;
            transition: transform 0.3s;
            transform: rotate(0deg);
        }

        .group-header.collapsed .group-toggle-icon {
            transform: rotate(180deg);
        }

        .group-name {
            font-size: 16px;
            font-weight: 600;
            color: #1e3a5f;
        }

        .group-count {
            background: #007bff;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .group-stats {
            display: flex;
            gap: 24px;
        }

        .group-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .group-stat-label {
            font-size: 11px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .group-stat-value {
            font-size: 18px;
            font-weight: 700;
        }

        .group-stat-value.good { color: #28a745; }
        .group-stat-value.fair { color: #ffc107; }
        .group-stat-value.poor { color: #dc3545; }

        .group-content {
            max-height: 8000px;
            overflow: auto;
            transition: max-height 0.5s ease;
        }

        .group-content.collapsed {
            max-height: 0;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed; /* Ensures fixed column widths are respected */
            min-width: 900px; /* Minimum width to prevent excessive compression */
        }

        .data-table thead {
            background: #f8f9fa;
        }

        .data-table th {
            padding: 14px 24px;
            text-align: left;
            font-size: 12px;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid #e9ecef;
            vertical-align: middle;
        }

        .data-table tbody tr {
            border-bottom: 1px solid #f8f9fa;
            transition: background 0.2s;
        }

        .data-table tbody tr:hover {
            background: #f8f9fa;
        }

        .data-table td {
            padding: 16px 24px; /* Match header padding more closely */
            position: relative;
            vertical-align: middle;
        }

        .sensor-cell {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .sensor-indicator {
            width: 8px;
            height: 32px;
            border-radius: 4px;
        }

        .sensor-indicator.good { background: #28a745; }
        .sensor-indicator.fair { background: #ffc107; }
        .sensor-indicator.poor { background: #dc3545; }

        .sensor-name {
            font-weight: 500;
            color: #212529;
        }

        .sensor-id {
            font-size: 12px;
            color: #6c757d;
        }

        .perf-value {
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            text-align: center;
            display: inline-block;
            min-width: 60px;
            font-size: 12px;
        }

        .perf-value.good {
            background: #d4edda;
            color: #155724;
        }

        .perf-value.fair {
            background: #fff3cd;
            color: #856404;
        }

        .perf-value.poor {
            background: #f8d7da;
            color: #721c24;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
        }

        /* Expand Button */
        .expand-btn {
            cursor: pointer;
            font-size: 16px;
            color: #6c757d;
            transition: transform 0.2s;
            user-select: none;
            transform: rotate(180deg);
        }

        .expand-btn:hover {
            color: #007bff;
        }

        .expand-btn.expanded {
            transform: rotate(0deg);
        }

        /* Expandable Detail */
        .detail-row {
            display: none;
            background: #f8f9fa;
        }

        .detail-row.active {
            display: table-row;
        }

        .detail-content {
            padding: 24px;
        }

        .detail-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #1e3a5f;
        }

        /* Timeline Visualization Styles */
        .timeline-section {
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 15px;
            max-width: 100%;
            overflow: hidden;
        }

        .timeline-container {
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin: 15px 0;
            background: white;
            min-height: 120px;
            padding: 10px;
            padding-left: 70px; /* Add space for row labels */
        }

        .timeline-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .timeline-row {
            position: relative;
            height: 24px;
            background: white;
            width: 100%;
            border-bottom: 1px solid #f0f0f0;
        }

        .timeline-row:last-child {
            border-bottom: none;
        }

        .timeline-day-header {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 6px 12px;
            margin: 8px 0 4px 0;
            font-size: 12px;
            font-weight: bold;
            color: #495057;
            width: 100%;
        }

        .timeline {
            position: relative;
            height: 24px;
            background: white;
            width: 100%;
        }

        .timeline-row-label {
            position: absolute;
            left: -60px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #666;
            width: 55px;
            text-align: right;
        }

        .event {
            position: absolute;
            width: 1px;
            cursor: pointer;
            border-radius: 1px;
        }

        .event.sensor {
            top: 2px;
            height: 9px;
        }

        .event.zone {
            top: 13px;
            height: 9px;
        }

        .event.sensor.occupied { background-color: #2c2c2c; }
        .event.sensor.unoccupied { background-color: #27ae60; }
        .event.zone.standby { background-color: #85d085; }
        .event.zone.occupied { background-color: #666666; }

        .violation {
            position: absolute;
            top: 2px;
            height: 20px;
            width: 1px;
            background-color: #8e44ad;
            border-radius: 1px;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(142, 68, 173, 0.8);
        }

        /* Zoom Loupe */
        .zoom-loupe {
            position: fixed;
            width: 600px;
            height: 140px;
            background: white;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            z-index: 1000;
            display: none;
            overflow: hidden;
        }

        .zoom-loupe.visible {
            display: block;
        }

        .zoom-header {
            background: #f8f9fa;
            padding: 4px 8px;
            font-size: 10px;
            font-weight: bold;
            color: #333;
            border-bottom: 1px solid #dee2e6;
        }

        .zoom-content {
            position: relative;
            height: 115px;
            background: white;
            padding: 5px 5px 10px 5px;
        }

        .zoom-timeline {
            position: relative;
            height: 100px;
            width: 100%;
            background: white;
        }

        .zoom-event {
            position: absolute;
            width: 2px;
            cursor: pointer;
            border-radius: 1px;
        }

        .zoom-event.sensor {
            top: 10px;
            height: 36px;
        }

        .zoom-event.zone {
            top: 56px;
            height: 36px;
        }

        .zoom-event.sensor.occupied { background-color: #2c2c2c; }
        .zoom-event.sensor.unoccupied { background-color: #27ae60; }
        .zoom-event.zone.standby { background-color: #85d085; }
        .zoom-event.zone.occupied { background-color: #666666; }

        .zoom-violation {
            position: absolute;
            top: 10px;
            height: 80px;
            width: 2px;
            background-color: #8e44ad;
            border-radius: 1px;
            box-shadow: 0 0 4px rgba(142, 68, 173, 0.8);
        }

        .zoom-labels {
            position: absolute;
            top: 5px;
            left: 2px;
            font-size: 8px;
            color: #666;
        }

        .zoom-labels .sensor-label {
            position: absolute;
            top: 18px;
        }

        .zoom-labels .zone-label {
            position: absolute;
            top: 64px;
        }

        /* Timeline Info */
        .timeline-info {
            background: #f9f9f9;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 0.85em;
            color: #666;
        }

        /* Violations Section */
        .violations-section {
            margin-top: 15px;
        }

        .collapsible-header {
            background: #e9ecef;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .collapsible-header:hover {
            background: #dee2e6;
        }

        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }

        .collapsible-content.expanded {
            max-height: 400px;
        }

        .violations-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 8px 0;
        }

        .violation-column {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
        }

        .violation-column-header {
            font-weight: bold;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid #eee;
            font-size: 0.85em;
        }

        .violation-item {
            margin: 2px 0;
            padding: 2px 4px;
            background: #f9f9f9;
            border-radius: 2px;
            font-size: 0.75em;
            color: #555;
        }

        /* Diverging Bar Chart */
        .correlation-chart {
            width: 480px;
            height: 50px;
            position: relative;
            margin: 8px auto;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background: #f8f9fa;
        }

        .chart-container {
            height: 100%;
            display: flex;
            position: relative;
        }

        .chart-center {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #dee2e6;
            z-index: 2;
        }

        .occupied-side {
            width: 50%;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            padding: 4px 0px 4px 4px;
        }

        .standby-side {
            width: 50%;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            padding: 4px 4px 4px 0px;
        }

        .sensor-bar, .bms-bar {
            height: 16px;
            position: relative;
            border-radius: 2px;
            margin: 2px 0;
        }

        /* Occupied bars grow leftward */
        .occupied-side .sensor-bar {
            background: #2c2c2c;
            margin-left: auto;
        }

        .occupied-side .bms-bar {
            background: rgba(102, 102, 102, 0.5);
            margin-left: auto;
        }

        /* Standby bars grow rightward */
        .standby-side .sensor-bar {
            background: #27ae60;
        }

        .standby-side .bms-bar {
            background: rgba(133, 208, 133, 0.5);
        }

        /* Divergence border styling */
        .divergence-warning {
            border: 2px solid #ffc107 !important;
        }

        .divergence-poor {
            border: 2px solid #dc3545 !important;
        }

        .bar-label {
            position: absolute;
            font-size: 9px;
            font-weight: 600;
            color: #333;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 1px 3px;
            border-radius: 2px;
            white-space: nowrap;
        }

        .occupied-side .bar-label {
            left: -2px;
            transform: translate(-100%, -50%);
        }

        .standby-side .bar-label {
            right: -2px;
            transform: translate(100%, -50%);
        }

        .center-label {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 8px;
            color: #666;
            font-weight: 500;
        }


        /* Missing Data Display */
        .missing-data-chart {
            width: 140px;
            height: 50px;
            position: relative;
            margin: 8px auto;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background: #f8f9fa;
        }

        .missing-data-bars {
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            padding: 4px;
        }

        .missing-sensor-bar,
        .missing-zone-bar {
            height: 18px;
            position: relative;
            border-radius: 2px;
            margin: 1px 0;
        }

        .missing-sensor-bar {
            background: linear-gradient(90deg, #dc3545, #e74c3c);
        }

        .missing-zone-bar {
            background: linear-gradient(90deg, #fd7e14, #ff8c42);
        }

        .missing-bar-label {
            position: absolute;
            font-size: 10px;
            font-weight: 600;
            color: white;
            top: 50%;
            transform: translateY(-50%);
            right: 4px;
            text-shadow: 0 1px 1px rgba(0,0,0,0.5);
        }

        /* Last Outage Display */
        .outage-info {
            text-align: center;
            padding: 8px 4px;
        }

        .outage-duration {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
        }

        .outage-when {
            font-size: 10px;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Commissioning Grid */
        .commissioning-grid {
            display: grid;
            grid-template-columns: auto 1fr 1fr;
            gap: 2px;
            font-size: 11px;
        }

        .commissioning-item {
            padding: 3px 5px;
            border-radius: 3px;
            text-align: center;
            font-weight: 500;
        }

        .commissioning-header {
            padding: 3px 5px;
            text-align: center;
            font-weight: 600;
            font-size: 10px;
            background: #f8f9fa;
            border-radius: 3px;
            color: #666;
        }

        .commissioning-row-label {
            padding: 3px 5px;
            text-align: right;
            font-weight: 600;
            font-size: 10px;
            background: #f8f9fa;
            border-radius: 3px;
            color: #666;
            white-space: nowrap;
        }

        .commissioning-item.good { background: #d4edda; color: #155724; }
        .commissioning-item.fair { background: #fff3cd; color: #856404; }
        .commissioning-item.poor { background: #f8d7da; color: #721c24; }

        /* Mini Chart */
        .mini-chart {
            width: 100px;
            height: 30px;
            background: #f8f9fa;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .chart-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: #007bff;
            opacity: 0.7;
        }

        /* Mock Data Indicator */
        .mock-data {
            border: 2px solid #dc3545 !important;
            position: relative;
        }

        .mock-data::after {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #dc3545;
            color: white;
            font-size: 9px;
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 3px;
            z-index: 10;
            white-space: nowrap;
        }

        .mock-data.data-quality::after { content: "DATA-QUALITY"; }
        .mock-data.out-of-spec::after { content: "OUT-OF-SPEC"; }
        .mock-data.bms-correlation::after { content: "BMS-CORR"; }
        .mock-data.commissioning::after { content: "COMMISSION"; }
        .mock-data.trend-chart::after { content: "24H-TREND"; }

        /* Special positioning for table cell mock data labels - move outside containers */
        td .mock-data::after {
            top: -20px;
            right: 0px;
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 3px;
            background: #dc3545;
            color: white;
            font-weight: bold;
            z-index: 20;
        }

        /* Real Data Indicator */
        .real-data {
            position: relative;
        }




        /* Remove individual margins since we're using cell padding */
        td .mock-data,
        td .real-data {
            margin-top: 0;
        }

        /* Reset correlation chart margins */
        .correlation-chart.mock-data,
        .correlation-chart.real-data,
        .commissioning-grid.mock-data,
        .mini-chart.mock-data {
            margin-top: 0;
        }

        /* New approach: HTML label elements */
        .table-cell-label {
            position: absolute;
            top: 4px;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 3px;
            z-index: 20;
            white-space: nowrap;
        }

        .table-cell-label.mock-label {
            background: #dc3545;
            color: white;
            right: 4px;
        }


        /* Ensure tooltips are visible */
        .table-cell-label[title] {
            z-index: 9999 !important;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
        }

        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 2rem;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #e9ecef;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6c757d;
            padding: 0.25rem;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: #f8f9fa;
            color: #dc3545;
        }

        .progress-section {
            margin: 1.5rem 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill.animating::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.02); }
            100% { opacity: 1; transform: scale(1); }
        }

        .status-message {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-weight: 500;
        }

        .status-info {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .status-success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .status-error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .execute-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s ease;
        }

        .execute-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }

        .execute-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .time-inputs {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
        }

        .input-group {
            flex: 1;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #555;
        }

        .input-group input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1rem;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        /* Enhanced Legend Panel */
        .legend-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.12);
            z-index: 1000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        .legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #eee;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 12px 12px 0 0;
        }

        .legend-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #2c3e50;
            font-size: 16px;
        }

        .legend-icon {
            font-size: 18px;
        }

        .collapse-btn {
            background: none;
            border: none;
            font-size: 20px;
            font-weight: bold;
            color: #6c757d;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .collapse-btn:hover {
            background: #f8f9fa;
            color: #495057;
        }

        .legend-content {
            max-height: 500px;
            overflow-y: auto;
            transition: max-height 0.3s ease;
        }

        .legend-content.collapsed {
            max-height: 0;
            overflow: hidden;
        }

        .legend-section {
            padding: 16px 20px;
            border-bottom: 1px solid #f8f9fa;
        }

        .legend-section:last-child {
            border-bottom: none;
        }

        .legend-section-title {
            font-weight: 600;
            color: #495057;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 13px;
            color: #6c757d;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-swatch {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .legend-swatch.occupied { background: #28a745; }
        .legend-swatch.unoccupied { background: #6c757d; }
        .legend-swatch.active { background: #007bff; }
        .legend-swatch.standby { background: #ffc107; }
        .legend-swatch.violation { background: #dc3545; }
        .legend-swatch.missing { background: repeating-linear-gradient(45deg, #f8f9fa, #f8f9fa 3px, #dee2e6 3px, #dee2e6 6px); }


        /* Progressive Information Hierarchy */
        .section-header {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 12px 16px;
            margin: 20px 0 15px 0;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
            margin: 0 0 4px 0;
        }

        .section-description {
            font-size: 14px;
            color: #6c757d;
            margin: 0;
        }

        .info-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: #17a2b8;
            color: white;
            border-radius: 50%;
            font-size: 10px;
            font-weight: bold;
            margin-left: 6px;
            cursor: help;
        }

        .tour-launch-btn {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 8px 12px;
            margin: 8px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .tour-launch-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .tour-launch-btn .info-indicator {
            background: rgba(255, 255, 255, 0.2);
            margin-left: 0;
            margin-right: 8px;
            font-size: 12px;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .legend-panel {
                width: 280px;
                right: 10px;
                top: 10px;
            }

            .tour-popup {
                max-width: 250px;
                padding: 15px;
            }
        }

        /* Guided Tour System with Right Sidebar */
        .tour-active body {
            margin-right: 400px;
        }

        .tour-sidebar {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            z-index: 10000;
            transition: right 0.3s ease;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
        }

        .tour-sidebar.active {
            right: 0;
        }

        .tour-sidebar-header {
            padding: 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.1);
        }

        .tour-sidebar-header h2 {
            margin: 0 0 8px 0;
            font-size: 20px;
            font-weight: 600;
        }

        .tour-sidebar-content {
            flex: 1;
            padding: 24px;
            display: flex;
            flex-direction: column;
        }

        .tour-step-counter {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 16px;
            text-align: center;
        }

        .tour-step-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            line-height: 1.3;
        }

        .tour-step-content {
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 24px;
            flex: 1;
        }

        .tour-navigation {
            display: flex;
            gap: 12px;
            margin-top: auto;
        }

        .tour-nav-btn {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .tour-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .tour-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tour-exit-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s ease;
        }

        .tour-exit-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .tour-highlight {
            position: absolute;
            background: rgba(102, 126, 234, 0.1);
            border: 3px solid #667eea;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            pointer-events: none;
            z-index: 9998;
            animation: pulse-highlight 2s infinite;
        }

        @keyframes pulse-highlight {
            0% { box-shadow: 0 0 20px rgba(102, 126, 234, 0.4); }
            50% { box-shadow: 0 0 30px rgba(102, 126, 234, 0.8); }
            100% { box-shadow: 0 0 20px rgba(102, 126, 234, 0.4); }
        }

        .tour-tooltip h3 {
            margin: 0 0 12px 0;
            color: #1e3a5f;
            font-size: 18px;
            font-weight: 600;
        }

        .tour-tooltip p {
            margin: 0 0 20px 0;
            color: #4a5568;
            line-height: 1.5;
            font-size: 14px;
        }

        .tour-tooltip .tour-step-counter {
            position: absolute;
            top: -12px;
            left: 20px;
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .tour-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        .tour-nav-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .tour-nav-btn:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .tour-nav-btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
            transform: none;
        }

        .tour-nav-btn.secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .tour-nav-btn.secondary:hover {
            background: #cbd5e0;
        }

        .tour-progress {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .tour-progress-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #e2e8f0;
            transition: all 0.2s ease;
        }

        .tour-progress-dot.active {
            background: #667eea;
        }

        .tour-progress-dot.completed {
            background: #48bb78;
        }

        /* Tour Start Button */
        .tour-start-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .tour-start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
        }

        .tour-start-btn .tour-icon {
            font-size: 16px;
        }

        /* Responsive adjustments for tour */
        @media (max-width: 768px) {
            .tour-tooltip {
                max-width: 300px;
                min-width: 280px;
                padding: 20px;
            }

            .tour-start-btn {
                top: 10px;
                right: 10px;
                padding: 10px 16px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Controls Validation & Continuous Commissioning</h1>
        <div class="header-subtitle" id="headerSubtitle">Interactive Tour with Sample Data | <span style="background: rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; font-weight: 600;">DEMO MODE</span></div>

        <!-- Start Guided Tour Button - Hidden since tour auto-starts -->
        <button class="tour-start-btn" onclick="startGuidedTour()" style="display: none;">
            <span class="tour-icon">ðŸŽ“</span>
            Start Guided Tour
        </button>
        <div class="dataset-info" id="datasetInfo" style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 6px; font-size: 14px; display: none;">
            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <span style="font-weight: 600;">Dataset:</span>
                    <span id="datasetRecords">Loading...</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <span style="font-weight: 600;">Timespan:</span>
                    <span id="datasetTimespan">Loading...</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <span style="font-weight: 600;">Source:</span>
                    <span id="datasetSource" style="padding: 2px 6px; border-radius: 3px; font-size: 12px; font-weight: 600;">Loading...</span>
                </div>
                <div style="margin-left: auto;">
                    <span id="datasetLastUpdated" style="font-size: 12px; opacity: 0.8;">Last updated: Loading...</span>
                </div>
            </div>
        </div>
    </div>



    <!-- Dataset Selection Section -->
    <div class="upload-section">
        <h3>Dataset Selection</h3>

        <!-- Tour Scenario Selector -->
        <div style="margin-bottom: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196f3;">
            <label for="tourScenario" style="display: block; margin-bottom: 8px; font-weight: 600; color: #1e3a5f;">Tour Scenario:</label>
            <select id="tourScenario" onchange="loadTourScenario()"
                   style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                <option value="data-gaps">Data Gaps - Missing Sensor Periods</option>
                <option value="severe-divergence">Severe Sensor/VAV Divergence - Poor Sync</option>
                <option value="mild-divergence">Mild Sensor/VAV Divergence - Good Sync</option>
                <option value="mixed-issues">Mixed Validation Issues - Various BMS Problems</option>
            </select>
            <div style="font-size: 0.8em; color: #666; margin-top: 5px;">
                Select different scenarios to explore how the dashboard identifies various BMS validation issues
            </div>
        </div>

        <!-- Customer Name Input -->
        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #28a745;">
            <label for="customerName" style="display: block; margin-bottom: 8px; font-weight: 600; color: #1e3a5f;">Customer Name:</label>
            <input type="text" id="customerName" placeholder="Enter customer/facility name"
                   style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;"
                   onchange="updateCustomerName()" />
        </div>

        <!-- Current Dataset Info -->
        <div id="currentDatasetInfo" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
            <strong>Current Dataset:</strong> <span id="currentDatasetName">No dataset loaded</span><br>
            <span id="currentDatasetDetails" style="font-size: 0.9em; color: #666;"></span>
        </div>

        <!-- Upload Data -->
        <div>
            <h4 style="margin-bottom: 15px; color: #1e3a5f;">Upload Data</h4>
            <div class="upload-area" id="uploadArea">
                <p>Drag and drop CSV file here or click to select</p>
                <input type="file" id="fileInput" accept=".csv" style="display: none;">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">Choose File</button>
                <button class="generate-test-btn" onclick="generateTestData()">Generate Test Data</button>
            </div>
        </div>

        <div id="uploadStatus"></div>
    </div>

    <div id="executive-dashboard" class="executive-dashboard">
        <div class="loading">Loading dashboard metrics...</div>
    </div>


    <div class="main-content">
        <div class="controls">
            <div class="filter-grid">
                <div class="time-period-toggle">
                    <button class="time-btn active" onclick="setTimePeriod('24h')">Latest 24 Hrs</button>
                    <button class="time-btn" onclick="setTimePeriod('5d')">5 Days</button>
                    <button class="time-btn" onclick="setTimePeriod('30d')">30 Days</button>
                </div>
            </div>
        </div>

        <div class="grouped-container" id="groupedContainer">
            <div class="loading">Upload data to view sensor metrics</div>
        </div>
    </div>

    <script>
        // Tour mode flag
        const TOUR_MODE = true;

        // API base URL (not used in tour mode)
        const API_BASE = window.location.hostname === 'localhost'
            ? 'http://localhost:8000'
            : window.location.origin;

        // Global state
        let currentData = null;
        let currentGrouping = 'building';
        let currentTimePeriod = '24h';
        let violationsData = {}; // Store violations by sensor ID for CSV export
        let currentTourScenario = 'data-gaps'; // Default scenario

        // Mock data for tour scenarios
        const TOUR_SCENARIOS = {
            'data-gaps': {
                name: 'FAKE Building with Data Gaps',
                dashboard: {
                    standby_mode_percent: 45.2,
                    airflow_reduction_percent: 35.1,
                    correlation_health: { good: 6, poor: 6 },
                    data_quality_percent: 78.3,
                    bms_quality_percent: 82.1,
                    sensor_quality_percent: 74.5
                },
                sensors: [
                    {
                        sensor_id: '115-4-01 presence',
                        zone_id: 'BV200',
                        sensor: '115-4-01 presence',
                        zone: 'BV200',
                        occupancy_ratio: 0.18,
                        zone_standby_percent: 78.2,
                        airflow_reduction_percent: 58.7,
                        correlation_score: 0.95,
                        total_deviations_count: 2,
                        total_mode_changes: 47,
                        es_count: 1,
                        ls_count: 1,
                        eo_count: 0,
                        lo_count: 0,
                        sensor_occupied_percent: 18.0,
                        zone_occupied_percent: 21.8,
                        sensor_unoccupied_percent: 80.5,
                        zone_missing_percent: 18.7,
                        sensor_missing_percent: 22.3
                    },
                    {
                        sensor_id: '115-4-06 presence',
                        zone_id: 'BV201',
                        sensor: '115-4-06 presence',
                        zone: 'BV201',
                        occupancy_ratio: 0.22,
                        zone_standby_percent: 68.9,
                        airflow_reduction_percent: 51.7,
                        correlation_score: 0.89,
                        total_deviations_count: 3,
                        total_mode_changes: 52,
                        es_count: 2,
                        ls_count: 1,
                        eo_count: 0,
                        lo_count: 0,
                        sensor_occupied_percent: 22.0,
                        zone_occupied_percent: 31.1,
                        sensor_unoccupied_percent: 76.8,
                        zone_missing_percent: 15.4,
                        sensor_missing_percent: 19.8
                    },
                    {
                        sensor_id: '115-4-09 presence',
                        zone_id: 'BV202',
                        sensor: '115-4-09 presence',
                        zone: 'BV202',
                        occupancy_ratio: 0.15,
                        zone_standby_percent: 82.5,
                        airflow_reduction_percent: 61.9,
                        correlation_score: 0.98,
                        total_deviations_count: 1,
                        total_mode_changes: 38,
                        es_count: 0,
                        ls_count: 1,
                        eo_count: 0,
                        lo_count: 0,
                        sensor_occupied_percent: 15.0,
                        zone_occupied_percent: 17.5,
                        sensor_unoccupied_percent: 84.2,
                        zone_missing_percent: 12.1,
                        sensor_missing_percent: 14.6
                    }
                ]
            },
            'severe-divergence': {
                name: 'FAKE Building with Severe Sensor/VAV Divergence',
                dashboard: {
                    standby_mode_percent: 22.4,
                    airflow_reduction_percent: 16.8,
                    correlation_health: { good: 2, poor: 10 },
                    data_quality_percent: 89.1,
                    bms_quality_percent: 91.3,
                    sensor_quality_percent: 86.9
                },
                sensors: [
                    {
                        sensor_id: '115-4-01 presence',
                        zone_id: 'BV200',
                        sensor: '115-4-01 presence',
                        zone: 'BV200',
                        occupancy_ratio: 0.25,
                        zone_standby_percent: 45.8,
                        airflow_reduction_percent: 34.4,
                        correlation_score: 0.28,
                        total_deviations_count: 12,
                        total_mode_changes: 68,
                        es_count: 6,
                        ls_count: 6,
                        eo_count: 2,
                        lo_count: 1,
                        sensor_occupied_percent: 25.0,
                        zone_occupied_percent: 54.2,
                        sensor_unoccupied_percent: 72.1,
                        zone_missing_percent: 2.3,
                        sensor_missing_percent: 2.9
                    },
                    {
                        sensor_id: '115-4-06 presence',
                        zone_id: 'BV201',
                        sensor: '115-4-06 presence',
                        zone: 'BV201',
                        occupancy_ratio: 0.28,
                        zone_standby_percent: 38.9,
                        airflow_reduction_percent: 29.2,
                        correlation_score: 0.19,
                        total_deviations_count: 18,
                        total_mode_changes: 74,
                        es_count: 9,
                        ls_count: 9,
                        eo_count: 3,
                        lo_count: 2,
                        sensor_occupied_percent: 28.0,
                        zone_occupied_percent: 61.1,
                        sensor_unoccupied_percent: 68.2,
                        zone_missing_percent: 3.1,
                        sensor_missing_percent: 3.8
                    },
                    {
                        sensor_id: '115-4-09 presence',
                        zone_id: 'BV202',
                        sensor: '115-4-09 presence',
                        zone: 'BV202',
                        occupancy_ratio: 0.21,
                        zone_standby_percent: 42.1,
                        airflow_reduction_percent: 31.6,
                        correlation_score: 0.34,
                        total_deviations_count: 8,
                        total_mode_changes: 56,
                        es_count: 4,
                        ls_count: 4,
                        eo_count: 1,
                        lo_count: 1,
                        sensor_occupied_percent: 21.0,
                        zone_occupied_percent: 57.9,
                        sensor_unoccupied_percent: 76.5,
                        zone_missing_percent: 2.1,
                        sensor_missing_percent: 2.5
                    }
                ]
            },
            'mild-divergence': {
                name: 'FAKE Building with Mild Sensor/VAV Divergence',
                dashboard: {
                    standby_mode_percent: 67.8,
                    airflow_reduction_percent: 51.2,
                    correlation_health: { good: 10, poor: 2 },
                    data_quality_percent: 96.4,
                    bms_quality_percent: 97.1,
                    sensor_quality_percent: 95.7
                },
                sensors: [
                    {
                        sensor_id: '115-4-01 presence',
                        zone_id: 'BV200',
                        sensor: '115-4-01 presence',
                        zone: 'BV200',
                        occupancy_ratio: 0.35,
                        zone_standby_percent: 18.4,
                        airflow_reduction_percent: 13.8,
                        correlation_score: 0.89,
                        total_deviations_count: 28,
                        total_mode_changes: 45,
                        es_count: 15,
                        ls_count: 13,
                        eo_count: 8,
                        lo_count: 6,
                        sensor_occupied_percent: 35.0,
                        zone_occupied_percent: 81.6,
                        sensor_unoccupied_percent: 61.2,
                        zone_missing_percent: 4.8,
                        sensor_missing_percent: 3.8
                    },
                    {
                        sensor_id: '115-4-06 presence',
                        zone_id: 'BV201',
                        sensor: '115-4-06 presence',
                        zone: 'BV201',
                        occupancy_ratio: 0.42,
                        zone_standby_percent: 12.8,
                        airflow_reduction_percent: 9.6,
                        correlation_score: 0.92,
                        total_deviations_count: 34,
                        total_mode_changes: 52,
                        es_count: 18,
                        ls_count: 16,
                        eo_count: 12,
                        lo_count: 8,
                        sensor_occupied_percent: 42.0,
                        zone_occupied_percent: 87.2,
                        sensor_unoccupied_percent: 52.1,
                        zone_missing_percent: 5.9,
                        sensor_missing_percent: 5.9
                    },
                    {
                        sensor_id: '115-4-09 presence',
                        zone_id: 'BV202',
                        sensor: '115-4-09 presence',
                        zone: 'BV202',
                        occupancy_ratio: 0.31,
                        zone_standby_percent: 14.6,
                        airflow_reduction_percent: 11.0,
                        correlation_score: 0.86,
                        total_deviations_count: 22,
                        total_mode_changes: 38,
                        es_count: 12,
                        ls_count: 10,
                        eo_count: 6,
                        lo_count: 4,
                        sensor_occupied_percent: 31.0,
                        zone_occupied_percent: 85.4,
                        sensor_unoccupied_percent: 64.8,
                        zone_missing_percent: 4.2,
                        sensor_missing_percent: 4.2
                    }
                ]
            },
            'mixed-issues': {
                name: 'FAKE Building with Mixed Validation Issues',
                dashboard: {
                    standby_mode_percent: 38.7,
                    airflow_reduction_percent: 29.0,
                    correlation_health: { good: 7, poor: 5 },
                    data_quality_percent: 91.5,
                    bms_quality_percent: 93.2,
                    sensor_quality_percent: 89.8
                },
                sensors: [
                    {
                        sensor_id: '115-4-01 presence',
                        zone_id: 'BV200',
                        sensor: '115-4-01 presence',
                        zone: 'BV200',
                        occupancy_ratio: 0.19,
                        zone_standby_percent: 72.1,
                        airflow_reduction_percent: 54.1,
                        correlation_score: 0.91,
                        total_deviations_count: 4,
                        total_mode_changes: 48,
                        es_count: 2,
                        ls_count: 2,
                        eo_count: 0,
                        lo_count: 0,
                        sensor_occupied_percent: 19.0,
                        zone_occupied_percent: 27.9,
                        sensor_unoccupied_percent: 79.5,
                        zone_missing_percent: 1.5,
                        sensor_missing_percent: 1.5
                    },
                    {
                        sensor_id: '115-4-06 presence',
                        zone_id: 'BV201',
                        sensor: '115-4-06 presence',
                        zone: 'BV201',
                        occupancy_ratio: 0.32,
                        zone_standby_percent: 25.8,
                        airflow_reduction_percent: 19.4,
                        correlation_score: 0.58,
                        total_deviations_count: 19,
                        total_mode_changes: 63,
                        es_count: 10,
                        ls_count: 9,
                        eo_count: 4,
                        lo_count: 3,
                        sensor_occupied_percent: 32.0,
                        zone_occupied_percent: 74.2,
                        sensor_unoccupied_percent: 64.8,
                        zone_missing_percent: 3.2,
                        sensor_missing_percent: 3.2
                    },
                    {
                        sensor_id: '115-4-09 presence',
                        zone_id: 'BV202',
                        sensor: '115-4-09 presence',
                        zone: 'BV202',
                        occupancy_ratio: 0.24,
                        zone_standby_percent: 38.2,
                        airflow_reduction_percent: 28.7,
                        correlation_score: 0.75,
                        total_deviations_count: 9,
                        total_mode_changes: 51,
                        es_count: 5,
                        ls_count: 4,
                        eo_count: 2,
                        lo_count: 1,
                        sensor_occupied_percent: 24.0,
                        zone_occupied_percent: 61.8,
                        sensor_unoccupied_percent: 73.5,
                        zone_missing_percent: 2.5,
                        sensor_missing_percent: 2.5
                    }
                ]
            }
        };

        // Generate mock timeline data for a sensor
        function generateMockTimelineData(sensorId, scenario) {
            const now = new Date();
            const startTime = new Date(now.getTime() - (24 * 60 * 60 * 1000)); // 24 hours ago
            const events = [];
            const violations = [];

            // Get scenario-specific parameters
            const sensorData = scenario.sensors.find(s => s.sensor_id === sensorId) || scenario.sensors[0];
            const scenarioKey = Object.keys(TOUR_SCENARIOS).find(key => TOUR_SCENARIOS[key] === scenario);

            let currentTime = new Date(startTime);
            let currentOccupancy = 0;
            let currentZoneMode = 0;

            // Generate data according to scenario story
            if (scenarioKey === 'data-gaps') {
                generateDataGapsScenario(events, violations, currentTime, now, sensorData);
            } else if (scenarioKey === 'severe-divergence') {
                generateSevereDivergenceScenario(events, violations, currentTime, now, sensorData);
            } else if (scenarioKey === 'mild-divergence') {
                generateMildDivergenceScenario(events, violations, currentTime, now, sensorData);
            } else {
                generateHighPerformanceScenario(events, violations, currentTime, now, sensorData);
            }

            return {
                sensor: sensorId,
                zone: sensorData.zone_id,
                events: events,
                violations: violations
            };
        }

        function generateDataGapsScenario(events, violations, startTime, endTime, sensorData) {
            let currentTime = new Date(startTime);
            let currentOccupancy = 0;
            let currentZoneMode = 0;

            while (currentTime < endTime) {
                const hour = currentTime.getHours();
                const minute = currentTime.getMinutes();

                // Create obvious data gaps (sensor missing periods)
                const isDataGapPeriod = (hour >= 10 && hour <= 11) || (hour >= 14 && hour <= 15);

                if (!isDataGapPeriod) {
                    // Generate sensor data every 30 seconds when not in gap
                    if (minute % 1 === 0 && currentTime.getSeconds() % 30 === 0) {
                        const isWorkHours = hour >= 8 && hour <= 17;
                        const occupancyProb = isWorkHours ? 0.4 : 0.05;
                        const newOccupancy = Math.random() < occupancyProb ? 1 : 0;

                        if (newOccupancy !== currentOccupancy) {
                            events.push({
                                timestamp: new Date(currentTime).toISOString(),
                                type: 'sensor',
                                value: newOccupancy,
                                sensor: sensorData.sensor_id
                            });
                            currentOccupancy = newOccupancy;
                        }
                    }

                    // Generate BMS zone data every minute (with good correlation)
                    if (currentTime.getSeconds() === 0) {
                        const expectedZoneMode = currentOccupancy;
                        const actualZoneMode = Math.random() < 0.95 ? expectedZoneMode : 1 - expectedZoneMode;

                        if (actualZoneMode !== currentZoneMode) {
                            events.push({
                                timestamp: new Date(currentTime).toISOString(),
                                type: 'zone',
                                value: actualZoneMode,
                                zone: sensorData.zone_id
                            });
                            currentZoneMode = actualZoneMode;
                        }
                    }
                }

                currentTime = new Date(currentTime.getTime() + 30 * 1000); // Advance 30 seconds
            }
        }

        function generateSevereDivergenceScenario(events, violations, startTime, endTime, sensorData) {
            let currentTime = new Date(startTime);
            let currentOccupancy = 0;
            let currentZoneMode = 0;

            while (currentTime < endTime) {
                const hour = currentTime.getHours();
                const minute = currentTime.getMinutes();

                // Generate sensor data every 30 seconds
                if (minute % 1 === 0 && currentTime.getSeconds() % 30 === 0) {
                    const isWorkHours = hour >= 8 && hour <= 17;
                    const occupancyProb = isWorkHours ? 0.6 : 0.1;
                    const newOccupancy = Math.random() < occupancyProb ? 1 : 0;

                    if (newOccupancy !== currentOccupancy) {
                        events.push({
                            timestamp: new Date(currentTime).toISOString(),
                            type: 'sensor',
                            value: newOccupancy,
                            sensor: sensorData.sensor_id
                        });
                        currentOccupancy = newOccupancy;
                    }
                }

                // Generate BMS zone data every minute (with POOR correlation - the story!)
                if (currentTime.getSeconds() === 0) {
                    // Zone often disagrees with sensor (severe divergence)
                    const shouldMatchSensor = Math.random() < 0.3; // Only 30% correlation
                    const newZoneMode = shouldMatchSensor ? currentOccupancy : (Math.random() < 0.7 ? 1 : 0);

                    if (newZoneMode !== currentZoneMode) {
                        events.push({
                            timestamp: new Date(currentTime).toISOString(),
                            type: 'zone',
                            value: newZoneMode,
                            zone: sensorData.zone_id
                        });

                        // Generate violations for severe mismatches
                        if (currentOccupancy === 0 && newZoneMode === 1) {
                            violations.push({
                                timestamp: new Date(currentTime).toISOString(),
                                type: 'late_standby',
                                message: `Zone stayed occupied despite no sensor activity`
                            });
                        } else if (currentOccupancy === 1 && newZoneMode === 0) {
                            violations.push({
                                timestamp: new Date(currentTime).toISOString(),
                                type: 'missed_occupied',
                                message: `Zone remained in standby despite sensor occupancy`
                            });
                        }

                        currentZoneMode = newZoneMode;
                    }
                }

                currentTime = new Date(currentTime.getTime() + 30 * 1000);
            }
        }

        function generateMildDivergenceScenario(events, violations, startTime, endTime, sensorData) {
            let currentTime = new Date(startTime);
            let currentOccupancy = 0;
            let currentZoneMode = 0;

            while (currentTime < endTime) {
                const hour = currentTime.getHours();
                const minute = currentTime.getMinutes();

                // Generate sensor data every 30 seconds
                if (minute % 1 === 0 && currentTime.getSeconds() % 30 === 0) {
                    const isWorkHours = hour >= 8 && hour <= 17;
                    const occupancyProb = isWorkHours ? 0.7 : 0.05;
                    const newOccupancy = Math.random() < occupancyProb ? 1 : 0;

                    if (newOccupancy !== currentOccupancy) {
                        events.push({
                            timestamp: new Date(currentTime).toISOString(),
                            type: 'sensor',
                            value: newOccupancy,
                            sensor: sensorData.sensor_id
                        });
                        currentOccupancy = newOccupancy;
                    }
                }

                // Generate BMS zone data every minute (with GOOD correlation - mild issues)
                if (currentTime.getSeconds() === 0) {
                    const shouldMatchSensor = Math.random() < 0.85; // 85% correlation (good but not perfect)
                    let newZoneMode = shouldMatchSensor ? currentOccupancy : currentZoneMode;

                    // Occasionally add timing delays (mild divergence)
                    if (!shouldMatchSensor && Math.random() < 0.3) {
                        newZoneMode = Math.random() < 0.5 ? 1 : 0;
                    }

                    if (newZoneMode !== currentZoneMode) {
                        events.push({
                            timestamp: new Date(currentTime).toISOString(),
                            type: 'zone',
                            value: newZoneMode,
                            zone: sensorData.zone_id
                        });

                        // Generate fewer violations (mild issues)
                        if (Math.random() < 0.2) { // Only 20% of changes create violations
                            violations.push({
                                timestamp: new Date(currentTime).toISOString(),
                                type: 'timing_delay',
                                message: `Minor timing delay in zone response`
                            });
                        }

                        currentZoneMode = newZoneMode;
                    }
                }

                currentTime = new Date(currentTime.getTime() + 30 * 1000);
            }
        }

        function generateHighPerformanceScenario(events, violations, startTime, endTime, sensorData) {
            let currentTime = new Date(startTime);
            let currentOccupancy = 0;
            let currentZoneMode = 0;

            while (currentTime < endTime) {
                const hour = currentTime.getHours();
                const minute = currentTime.getMinutes();

                // Generate sensor data every 30 seconds
                if (minute % 1 === 0 && currentTime.getSeconds() % 30 === 0) {
                    const isWorkHours = hour >= 8 && hour <= 17;
                    const occupancyProb = isWorkHours ? 0.6 : 0.02;
                    const newOccupancy = Math.random() < occupancyProb ? 1 : 0;

                    if (newOccupancy !== currentOccupancy) {
                        events.push({
                            timestamp: new Date(currentTime).toISOString(),
                            type: 'sensor',
                            value: newOccupancy,
                            sensor: sensorData.sensor_id
                        });
                        currentOccupancy = newOccupancy;
                    }
                }

                // Generate BMS zone data every minute (with EXCELLENT correlation)
                if (currentTime.getSeconds() === 0) {
                    const shouldMatchSensor = Math.random() < 0.98; // 98% correlation (excellent)
                    const newZoneMode = shouldMatchSensor ? currentOccupancy : currentZoneMode;

                    if (newZoneMode !== currentZoneMode) {
                        events.push({
                            timestamp: new Date(currentTime).toISOString(),
                            type: 'zone',
                            value: newZoneMode,
                            zone: sensorData.zone_id
                        });
                        currentZoneMode = newZoneMode;
                    }
                }

                currentTime = new Date(currentTime.getTime() + 30 * 1000);
            }
        }

        // Enhanced Legend System Functions
        function toggleLegend() {
            const content = document.getElementById('legendContent');
            const btn = document.querySelector('.collapse-btn');

            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                btn.textContent = 'âˆ’';
            } else {
                content.classList.add('collapsed');
                btn.textContent = '+';
            }
        }

        function launchTour() {
            // This function is not used in tour mode
            alert('You are already in the interactive tour!');
        }

        // Load selected tour scenario
        async function loadTourScenario() {
            if (!TOUR_MODE) return;

            const selector = document.getElementById('tourScenario');
            currentTourScenario = selector.value;
            const scenario = TOUR_SCENARIOS[currentTourScenario];

            // Update customer name to scenario name
            document.getElementById('customerName').value = scenario.name;
            updateCustomerName();

            // Update current dataset info
            updateCurrentDatasetInfo(scenario.name, `Tour scenario - 3 sensors, 24 hours`);

            // Load dashboard data with mock data
            await loadDashboardData();
        }


        // File upload handling
        document.getElementById('fileInput').addEventListener('change', handleFileUpload);

        const uploadArea = document.getElementById('uploadArea');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                uploadFile(files[0]);
            }
        });

        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                await uploadFile(file);
            }
        }

        async function uploadFile(file) {
            if (TOUR_MODE) {
                // In tour mode, simulate upload and show high-performance scenario
                const statusDiv = document.getElementById('uploadStatus');
                statusDiv.innerHTML = '<div class="loading">Processing mock file...</div>';

                setTimeout(async () => {
                    statusDiv.innerHTML = `<div class="success">Mock file processed! Showing tour data for ${file.name}.</div>`;
                    const selector = document.getElementById('tourScenario');
                    selector.value = 'high-performance';
                    await loadTourScenario();
                }, 1000);
                return;
            }

            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.innerHTML = '<div class="loading">Uploading and processing file...</div>';

            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch(`${API_BASE}/api/upload`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`Upload failed: ${response.statusText}`);
                }

                const result = await response.json();
                statusDiv.innerHTML = `<div class="success">File uploaded successfully! Processed ${result.records_count} records.</div>`;

                // Update current dataset info
                updateCurrentDatasetInfo(file.name, `Upload - ${result.records_count} records`);

                // Load dashboard data
                await loadDashboardData();

            } catch (error) {
                statusDiv.innerHTML = `<div class="error">Upload failed: ${error.message}</div>`;
            }
        }

        async function loadPresetDataset(datasetKey) {
            if (TOUR_MODE) {
                // In tour mode, just select the first scenario
                const selector = document.getElementById('tourScenario');
                selector.value = 'high-performance';
                await loadTourScenario();
                return;
            }

            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.innerHTML = '<div class="loading">Loading preset dataset...</div>';

            try {
                let response;

                // For database dataset, use the same API base (Railway will handle routing)
                if (datasetKey === 'database') {
                    response = await fetch(`${API_BASE}/api/load-dataset`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ dataset: datasetKey })
                    });
                } else {
                    // For other datasets, use the main API server
                    response = await fetch(`${API_BASE}/api/load-dataset`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ dataset: datasetKey })
                    });
                }

                if (!response.ok) {
                    throw new Error(`Failed to load dataset: ${response.statusText}`);
                }

                const result = await response.json();
                statusDiv.innerHTML = `<div class="success">Dataset loaded successfully! Processed ${result.records_count} records.</div>`;

                // Update current dataset info
                const datasetInfo = {
                    'SCH-1_data_30_days_mock': { name: '30 Days / 100 Sensors (Mock)', details: 'Full dataset with BV zones' },
                    'SCH-1_data_5_days_mock': { name: '5 Days / 100 Sensors (Mock)', details: 'Medium dataset with BV zones' },
                    'SCH-1_data_1_day_mock': { name: '1 Day / 100 Sensors (Mock)', details: 'Quick test dataset' },
                    'SCH-1_data_20250916': { name: 'Real Data - 23.5 Hours', details: 'Actual sensor data from Sept 16' },
                    'SCH1_Since915': { name: 'Real Data - 4 Days', details: 'Extended dataset from Sept 15-19' },
                    'database': { name: 'Live Database Data', details: 'Latest data from TimescaleDB' }
                };

                const info = datasetInfo[datasetKey] || { name: datasetKey, details: 'Unknown dataset' };
                updateCurrentDatasetInfo(info.name, `${info.details} - ${result.records_count} records`);

                // Load dashboard data
                await loadDashboardData();

            } catch (error) {
                statusDiv.innerHTML = `<div class="error">Failed to load preset dataset: ${error.message}</div>`;
            }
        }

        function updateCurrentDatasetInfo(name, details) {
            document.getElementById('currentDatasetName').textContent = name;
            document.getElementById('currentDatasetDetails').textContent = details;
        }

        function updateCustomerName() {
            const customerName = document.getElementById('customerName').value.trim();
            const headerSubtitle = document.getElementById('headerSubtitle');

            if (customerName) {
                headerSubtitle.textContent = `${customerName} - API Powered Dashboard`;
            } else {
                headerSubtitle.textContent = 'API Powered Dashboard';
            }
        }

        // Dataset info tracking
        let lastDatasetInfo = null;
        let datasetInfoInterval = null;

        async function fetchDatasetInfo() {
            if (TOUR_MODE) {
                // In tour mode, return mock dataset info
                const scenario = TOUR_SCENARIOS[currentTourScenario] || TOUR_SCENARIOS['high-performance'];
                const mockData = {
                    name: scenario.name,
                    details: `Tour scenario - 3 sensors, 24 hours`,
                    sensors_count: 3,
                    records_count: 1440, // 24 hours * 60 minutes
                    time_range: "2025-09-16 00:00 to 2025-09-17 00:00"
                };
                updateDatasetInfoDisplay(mockData);
                checkForDatasetChanges(mockData);
                return mockData;
            }

            try {
                const response = await fetch('/api/dataset-info');
                const data = await response.json();
                updateDatasetInfoDisplay(data);
                checkForDatasetChanges(data);
                return data;
            } catch (error) {
                console.error('Failed to fetch dataset info:', error);
                return null;
            }
        }

        function updateDatasetInfoDisplay(data) {
            const datasetInfo = document.getElementById('datasetInfo');
            const recordsElement = document.getElementById('datasetRecords');
            const timespanElement = document.getElementById('datasetTimespan');
            const sourceElement = document.getElementById('datasetSource');
            const lastUpdatedElement = document.getElementById('datasetLastUpdated');

            if (data && data.record_count > 0) {
                datasetInfo.style.display = 'block';

                // Format record count with commas
                recordsElement.textContent = data.record_count.toLocaleString() + ' records';

                // Format timespan
                if (data.earliest_timestamp && data.latest_timestamp) {
                    const earliest = new Date(data.earliest_timestamp);
                    const latest = new Date(data.latest_timestamp);
                    const timespanStr = `${earliest.toLocaleDateString()} - ${latest.toLocaleDateString()} (${data.timespan_hours}h)`;
                    timespanElement.textContent = timespanStr;
                } else {
                    timespanElement.textContent = 'Unknown timespan';
                }

                // Format data source with color coding
                sourceElement.textContent = data.data_source.toUpperCase();
                sourceElement.style.backgroundColor = data.data_source === 'database' ? '#28a745' : '#007bff';
                sourceElement.style.color = 'white';

                // Format last updated
                const loadTime = new Date(data.load_timestamp);
                lastUpdatedElement.textContent = `Last updated: ${loadTime.toLocaleTimeString()}`;
            } else {
                datasetInfo.style.display = 'none';
            }
        }

        function checkForDatasetChanges(newData) {
            if (lastDatasetInfo && newData) {
                // Check if dataset has changed (different record count or timespan)
                if (lastDatasetInfo.record_count !== newData.record_count ||
                    lastDatasetInfo.timespan_hours !== newData.timespan_hours) {

                    console.warn('ðŸš¨ DATASET CHANGE DETECTED!');
                    console.warn('Previous:', lastDatasetInfo);
                    console.warn('Current:', newData);

                    // Show warning in UI
                    showDatasetChangeWarning(lastDatasetInfo, newData);
                }
            }
            lastDatasetInfo = newData;
        }

        function showDatasetChangeWarning(oldData, newData) {
            const warningDiv = document.createElement('div');
            warningDiv.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 10000;
                background: #dc3545; color: white; padding: 15px; border-radius: 8px;
                max-width: 400px; font-size: 14px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            warningDiv.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 8px;">ðŸ“Š Dataset Updated</div>
                <div>Previous: ${oldData.record_count.toLocaleString()} records</div>
                <div>Current: ${newData.record_count.toLocaleString()} records</div>
                <button onclick="this.parentElement.remove()" style="margin-top: 10px; background: white; color: #dc3545; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">Close</button>
            `;
            document.body.appendChild(warningDiv);

            // Auto-remove after 10 seconds
            setTimeout(() => {
                if (warningDiv.parentElement) {
                    warningDiv.remove();
                }
            }, 10000);
        }

        function startDatasetInfoUpdates() {
            if (TOUR_MODE) {
                // In tour mode, skip periodic updates and just do initial fetch
                fetchDatasetInfo();
                return;
            }

            // Initial fetch
            fetchDatasetInfo();

            // Update every 30 seconds
            if (datasetInfoInterval) {
                clearInterval(datasetInfoInterval);
            }
            datasetInfoInterval = setInterval(fetchDatasetInfo, 30000);
        }

        function stopDatasetInfoUpdates() {
            if (datasetInfoInterval) {
                clearInterval(datasetInfoInterval);
                datasetInfoInterval = null;
            }
        }

        async function generateTestData() {
            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.innerHTML = '<div class="loading">Generating test data...</div>';

            try {
                const response = await fetch(`${API_BASE}/api/generate-test-data?sensors=100&days=30`);

                if (!response.ok) {
                    throw new Error(`Generation failed: ${response.statusText}`);
                }

                const result = await response.json();
                statusDiv.innerHTML = `<div class="success">${result.message}</div>`;

                // Load dashboard data
                await loadDashboardData();

            } catch (error) {
                statusDiv.innerHTML = `<div class="error">Test data generation failed: ${error.message}</div>`;
            }
        }

        async function loadDashboardData() {
            console.log(`ðŸš€ [DEBUG] Starting loadDashboardData() for period: ${currentTimePeriod}`);
            try {
                // Load dashboard metrics
                console.log(`ðŸ“Š [DEBUG] Loading dashboard metrics...`);
                await loadDashboardMetrics();
                console.log(`âœ… [DEBUG] Dashboard metrics loaded successfully`);

                // Load sensor metrics
                console.log(`ðŸ”§ [DEBUG] Loading sensor metrics...`);
                await loadSensorMetrics();
                console.log(`âœ… [DEBUG] Sensor metrics loaded successfully`);

            } catch (error) {
                console.error('âŒ [ERROR] Failed to load dashboard data:', error);
                console.error('âŒ [ERROR] Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack,
                    currentTimePeriod: currentTimePeriod
                });

                // Show detailed error to user
                document.getElementById('executive-dashboard').innerHTML =
                    `<div class="error">
                        <h3>Failed to load dashboard data</h3>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p><strong>Time Period:</strong> ${currentTimePeriod}</p>
                        <p><strong>Suggestion:</strong> Try switching to a shorter time period (24h) if the current period is timing out.</p>
                    </div>`;
            }
        }

        async function loadDashboardMetrics() {
            console.log(`ðŸ” [DEBUG] Loading dashboard metrics for period: ${currentTimePeriod}`);

            let metrics;
            if (TOUR_MODE) {
                // Use mock data in tour mode
                const scenario = TOUR_SCENARIOS[currentTourScenario];
                metrics = scenario.dashboard;
                console.log(`ðŸ” [DEBUG] Using mock data for scenario: ${currentTourScenario}`);
            } else {
                console.log(`ðŸ” [DEBUG] Fetching URL: ${API_BASE}/api/dashboard/metrics?period=${currentTimePeriod}`);

                const startTime = performance.now();
                const response = await fetch(`${API_BASE}/api/dashboard/metrics?period=${currentTimePeriod}`);
                const responseTime = performance.now() - startTime;

                console.log(`ðŸ” [DEBUG] API Response received in ${responseTime.toFixed(2)}ms`);
                console.log(`ðŸ” [DEBUG] Response status: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    console.error(`âŒ [ERROR] API failed: ${response.status} ${response.statusText}`);
                    throw new Error('Failed to load dashboard metrics');
                }

                metrics = await response.json();
            }
            console.log(`ðŸ” [DEBUG] Raw metrics data received:`, metrics);
            console.log(`ðŸ” [DEBUG] Standby mode: ${metrics.standby_mode_percent}%`);
            console.log(`ðŸ” [DEBUG] Airflow reduction: ${metrics.airflow_reduction_percent}%`);
            console.log(`ðŸ” [DEBUG] Correlation health:`, metrics.correlation_health);

            // Check if we have mostly zero values
            const hasLowPerformance = metrics.standby_mode_percent === 0 && metrics.airflow_reduction_percent === 0;
            const alertBanner = hasLowPerformance ? `
                <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 15px; margin-bottom: 20px; color: #856404;">
                    <strong>âš ï¸ Low Energy Savings Detected</strong><br>
                    This time period shows minimal energy savings. Consider:
                    <ul style="margin: 8px 0 0 20px; line-height: 1.4;">
                        <li>Testing a longer time period (30 days) for better analysis</li>
                        <li>Checking if BMS controls are properly configured</li>
                        <li>Verifying sensor-to-zone mappings are correct</li>
                    </ul>
                </div>
            ` : '';

            document.getElementById('executive-dashboard').innerHTML = `
                <div class="dashboard-title">System Performance Overview</div>
                <div class="analysis-period">
                    Analysis Period: ${(() => {
                        const periodDisplay = {
                            '24h': 'Latest 24 Hours',
                            '5d': 'Latest 5 Days',
                            '30d': 'Latest 30 Days'
                        }[currentTimePeriod] || 'Latest 24 Hours';
                        return periodDisplay;
                    })()}
                </div>
                ${alertBanner}
                <div class="dashboard-grid">
                    <div class="dashboard-metric">
                        <div class="metric-title">Standby Mode</div>
                        <div class="metric-value real-data exec-1" style="color: ${metrics.standby_mode_percent > 50 ? '#28a745' : metrics.standby_mode_percent > 30 ? '#ffc107' : '#dc3545'};" title="Percentage of time that zones cut VAV by 75%. Calculated by aggregating total standby time across all sensor/zone pairs divided by total duration. Higher percentages indicate better energy efficiency. Target: >50% for optimal savings.">
                            ${metrics.standby_mode_percent.toFixed(1)}%
                        </div>
                        <div class="metric-subtitle">
                            ${metrics.standby_mode_percent === 0 ?
                                'âš ï¸ No energy savings detected in this period' :
                                'Percentage of time that zones cut VAV by 75%'}
                        </div>
                        ${metrics.standby_mode_percent === 0 ?
                            '<div style="font-size: 0.8em; color: #666; margin-top: 5px;">ðŸ’¡ Try a longer time period (30 days) for better analysis</div>' :
                            ''}
                    </div>

                    <div class="dashboard-metric">
                        <div class="metric-title">Airflow reduction</div>
                        <div class="metric-value real-data exec-2" style="color: ${metrics.airflow_reduction_percent > 15 ? '#28a745' : '#ffc107'};" title="Actual airflow reduction achieved by multiplying standby mode percentage by VAV reduction factor (75%). Calculated as: Standby Mode % Ã— 0.75. Target: >15% for good energy performance.">
                            ${metrics.airflow_reduction_percent.toFixed(1)}%
                        </div>
                        <div class="metric-subtitle">
                            ${metrics.airflow_reduction_percent === 0 ?
                                'âš ï¸ No airflow reduction achieved' :
                                'Standby Mode Ã— 75% VAV reduction'}
                        </div>
                        ${metrics.airflow_reduction_percent === 0 ?
                            '<div style="font-size: 0.8em; color: #666; margin-top: 5px;">ðŸ’¡ Derived from standby mode - check BMS controls</div>' :
                            ''}
                    </div>

                    <div class="dashboard-metric">
                        <div class="metric-title">Correlation Health</div>
                        <div class="metric-value real-data exec-3" style="color: ${metrics.correlation_health.good > metrics.correlation_health.poor ? '#28a745' : '#dc3545'};" title="Number of sensors with good BMS-to-sensor correlation. Good correlation means zone standby time is 80-120% of sensor unoccupied time, indicating the BMS properly responds to occupancy detection. Poor correlation suggests timing issues or misconfigured controls.">
                            ${metrics.correlation_health.good} of ${metrics.correlation_health.good + metrics.correlation_health.poor}
                        </div>
                        <div class="metric-subtitle">sensors with good correlation</div>
                    </div>

                    <div class="dashboard-metric real-data data-quality">
                        <div class="metric-title">Data Completeness</div>
                        <div class="metric-value real-data" style="color: ${metrics.data_quality_percent > 95 ? '#28a745' : metrics.data_quality_percent > 80 ? '#ffc107' : '#dc3545'};" title="Percentage of valid data records (0 or 1 values) based on expected data rates: 2 points/minute for sensors, 1 point/minute for BMS. Calculated by comparing actual valid points to expected totals for the time period.">${metrics.data_quality_percent.toFixed(1)}%</div>
                        <div class="metric-subtitle">BMS: ${metrics.bms_quality_percent.toFixed(1)}% | Sensors: ${metrics.sensor_quality_percent.toFixed(1)}%</div>
                    </div>
                </div>
            `;
        }

        async function loadSensorMetrics() {
            let sensors;
            if (TOUR_MODE) {
                // Use mock data in tour mode
                const scenario = TOUR_SCENARIOS[currentTourScenario];
                sensors = scenario.sensors;
                console.log(`ðŸ” [DEBUG] Using mock sensor data for scenario: ${currentTourScenario}`);
            } else {
                const response = await fetch(`${API_BASE}/api/sensors/metrics?period=${currentTimePeriod}`);
                if (!response.ok) {
                    throw new Error('Failed to load sensor metrics');
                }
                sensors = await response.json();
            }
            renderSensorTable(sensors);
        }

        // Calculate divergence border class based on sensor vs BMS percentages
        function getDivergenceBorderClass(sensorPercent, bmsPercent) {
            const divergence = Math.abs(sensorPercent - bmsPercent);
            if (divergence < 10) return ''; // No border for good sync
            if (divergence < 20) return 'divergence-warning';
            return 'divergence-poor';
        }

        function renderSensorTable(sensors) {
            const container = document.getElementById('groupedContainer');

            if (sensors.length === 0) {
                container.innerHTML = '<div class="loading">No sensor data available</div>';
                return;
            }

            // Group sensors by building-floor (115-X format)
            // TODO: Make grouping pattern configurable in the future
            const groupedSensors = {};
            sensors.forEach(sensor => {
                const parts = sensor.sensor_id.split('-');
                const buildingFloor = parts.length >= 2 ? `${parts[0]}-${parts[1]}` : (parts[0] || 'Unknown');
                if (!groupedSensors[buildingFloor]) {
                    groupedSensors[buildingFloor] = [];
                }
                groupedSensors[buildingFloor].push(sensor);
            });

            container.innerHTML = '';

            Object.keys(groupedSensors).forEach((building, groupIndex) => {
                const groupSensors = groupedSensors[building];

                // Calculate group statistics
                const avgStandby = groupSensors.reduce((sum, s) => sum + s.zone_standby_percent, 0) / groupSensors.length;

                // Calculate real out of spec percentage using deviations/mode_changes
                const totalDeviations = groupSensors.reduce((sum, s) => sum + s.total_deviations_count, 0);
                const totalModeChanges = groupSensors.reduce((sum, s) => sum + s.total_mode_changes, 0);
                const outOfSpecPct = totalModeChanges > 0 ? (totalDeviations / totalModeChanges) * 100 : 0;

                // Create group header
                const groupHeader = document.createElement('div');
                groupHeader.className = 'group-header collapsed';
                groupHeader.onclick = () => toggleGroup(groupIndex);
                groupHeader.innerHTML = `
                    <div class="group-info">
                        <span class="group-toggle-icon">^</span>
                        <span class="group-name">${building}</span>
                        <span class="group-count">${groupSensors.length} sensors</span>
                    </div>
                    <div class="group-stats">
                        <div class="group-stat">
                            <span class="group-stat-label">Standby</span>
                            <span class="group-stat-value real-data group-1 ${avgStandby > 60 ? 'good' : avgStandby > 40 ? 'fair' : 'poor'}">
                                ${avgStandby.toFixed(0)}%
                            </span>
                        </div>
                        <div class="group-stat real-data out-of-spec">
                            <span class="group-stat-label">Out of Spec</span>
                            <span class="group-stat-value ${outOfSpecPct < 15 ? 'good' : outOfSpecPct < 30 ? 'fair' : 'poor'}">
                                ${outOfSpecPct.toFixed(0)}%
                            </span>
                        </div>
                    </div>
                `;
                container.appendChild(groupHeader);

                // Create group content
                const groupContent = document.createElement('div');
                groupContent.className = 'group-content collapsed';
                groupContent.id = `group-${groupIndex}`;

                const table = document.createElement('table');
                table.className = 'data-table';
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th style="width: 4%;"></th>
                            <th style="width: 20%;">Sensor / VAV</th>
                            <th style="width: 30%; text-align: center;">â† Occupied | Standby â†’</th>
                            <th style="width: 10%; text-align: center;">Missing Data</th>
                            <th style="width: 10%; text-align: center;">Last Outage</th>
                            <th style="width: 16%; text-align: center;">Commissioning</th>
                            <th style="width: 10%; text-align: center;">24h Trend</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${groupSensors.map((sensor, index) => `
                        <tr>
                            <td style="text-align: center; width: 4%;">
                                <span class="expand-btn" onclick="toggleDetail(${groupIndex}, ${index}, '${sensor.sensor_id}')">^</span>
                            </td>
                            <td style="width: 20%;">
                                <div class="sensor-cell">
                                    <div>
                                        <div class="sensor-name">${sensor.sensor_id}</div>
                                        <div class="sensor-id">${sensor.zone_id}</div>
                                    </div>
                                </div>
                            </td>
                            <td style="width: 35%; text-align: center;">
                                <div class="correlation-chart" title="Diverging bar chart showing occupancy correlation. Left side shows occupied percentages (sensor vs BMS). Right side shows standby percentages. Well-balanced systems show symmetrical patterns.">
                                    <div class="chart-container">
                                        <div class="occupied-side">
                                            <div class="sensor-bar ${getDivergenceBorderClass(sensor.sensor_occupied_percent, sensor.zone_occupied_percent)}" style="width: ${sensor.sensor_occupied_percent}%;" title="Sensor Occupied: ${sensor.sensor_occupied_percent.toFixed(0)}% - ${Math.abs(sensor.sensor_occupied_percent - sensor.zone_occupied_percent) < 10 ? 'Good sync' : Math.abs(sensor.sensor_occupied_percent - sensor.zone_occupied_percent) < 20 ? 'Minor drift (' + Math.abs(sensor.sensor_occupied_percent - sensor.zone_occupied_percent).toFixed(0) + '% divergence)' : 'Poor sync (' + Math.abs(sensor.sensor_occupied_percent - sensor.zone_occupied_percent).toFixed(0) + '% divergence)'}">
                                                <span class="bar-label">${sensor.sensor_occupied_percent.toFixed(0)}%</span>
                                            </div>
                                            <div class="bms-bar ${getDivergenceBorderClass(sensor.sensor_occupied_percent, sensor.zone_occupied_percent)}" style="width: ${sensor.zone_occupied_percent}%;" title="BMS Occupied: ${sensor.zone_occupied_percent.toFixed(0)}% - ${Math.abs(sensor.sensor_occupied_percent - sensor.zone_occupied_percent) < 10 ? 'Good sync' : Math.abs(sensor.sensor_occupied_percent - sensor.zone_occupied_percent) < 20 ? 'Minor drift (' + Math.abs(sensor.sensor_occupied_percent - sensor.zone_occupied_percent).toFixed(0) + '% divergence)' : 'Poor sync (' + Math.abs(sensor.sensor_occupied_percent - sensor.zone_occupied_percent).toFixed(0) + '% divergence)'}">
                                                <span class="bar-label">${sensor.zone_occupied_percent.toFixed(0)}%</span>
                                            </div>
                                        </div>
                                        <div class="chart-center">
                                        </div>
                                        <div class="standby-side">
                                            <div class="sensor-bar ${getDivergenceBorderClass(sensor.sensor_unoccupied_percent, sensor.zone_standby_percent)}" style="width: ${sensor.sensor_unoccupied_percent}%;" title="Sensor Unoccupied: ${sensor.sensor_unoccupied_percent.toFixed(0)}% - ${Math.abs(sensor.sensor_unoccupied_percent - sensor.zone_standby_percent) < 10 ? 'Good sync' : Math.abs(sensor.sensor_unoccupied_percent - sensor.zone_standby_percent) < 20 ? 'Minor drift (' + Math.abs(sensor.sensor_unoccupied_percent - sensor.zone_standby_percent).toFixed(0) + '% divergence)' : 'Poor sync (' + Math.abs(sensor.sensor_unoccupied_percent - sensor.zone_standby_percent).toFixed(0) + '% divergence)'}">
                                                <span class="bar-label">${sensor.sensor_unoccupied_percent.toFixed(0)}%</span>
                                            </div>
                                            <div class="bms-bar ${getDivergenceBorderClass(sensor.sensor_unoccupied_percent, sensor.zone_standby_percent)}" style="width: ${sensor.zone_standby_percent}%;" title="BMS Standby: ${sensor.zone_standby_percent.toFixed(0)}% - ${Math.abs(sensor.sensor_unoccupied_percent - sensor.zone_standby_percent) < 10 ? 'Good sync' : Math.abs(sensor.sensor_unoccupied_percent - sensor.zone_standby_percent) < 20 ? 'Minor drift (' + Math.abs(sensor.sensor_unoccupied_percent - sensor.zone_standby_percent).toFixed(0) + '% divergence)' : 'Poor sync (' + Math.abs(sensor.sensor_unoccupied_percent - sensor.zone_standby_percent).toFixed(0) + '% divergence)'}">
                                                <span class="bar-label">${sensor.zone_standby_percent.toFixed(0)}%</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </td>
                            <td style="width: 10%; text-align: center;">
                                <div class="missing-data-chart" title="Missing data percentages shown as horizontal bars. Top: sensor missing data, Bottom: VAV missing data. Lower percentages indicate better data quality.">
                                    <div class="missing-data-bars">
                                        <div class="missing-sensor-bar" style="width: ${Math.min(sensor.sensor_missing_percent, 100)}%;">
                                            <span class="missing-bar-label">${sensor.sensor_missing_percent.toFixed(0)}%</span>
                                        </div>
                                        <div class="missing-zone-bar" style="width: ${Math.min(sensor.zone_missing_percent, 100)}%;">
                                            <span class="missing-bar-label">${sensor.zone_missing_percent.toFixed(0)}%</span>
                                        </div>
                                    </div>
                                </div>
                            </td>
                            <td style="width: 10%; text-align: center;">
                                <div class="outage-info" title="Most recent data outage lasting more than 5 minutes. Shows duration in HH:MM format.">
                                    <div class="outage-duration">${sensor.last_outage_duration || '--:--'}</div>
                                    <div class="outage-when">${sensor.last_outage_when || 'None'}</div>
                                </div>
                            </td>
                            <td style="width: 16%; text-align: center;">
                                <div class="commissioning-grid" title="Commissioning deviation counts. Early: zone responds before minimum time. Late: zone delays response beyond maximum time. Standby: transitions to/from standby mode. Occupied: transitions to/from occupied mode.">
                                    <!-- Headers -->
                                    <div class="commissioning-header"></div>
                                    <div class="commissioning-header">Early</div>
                                    <div class="commissioning-header">Late</div>

                                    <!-- Standby row -->
                                    <div class="commissioning-row-label">Standby</div>
                                    <div class="commissioning-item ${sensor.es_count === 0 ? 'good' : sensor.es_count <= 1 ? 'fair' : 'poor'}">
                                        ${sensor.es_count}
                                    </div>
                                    <div class="commissioning-item ${sensor.ls_count === 0 ? 'good' : sensor.ls_count <= 1 ? 'fair' : 'poor'}">
                                        ${sensor.ls_count}
                                    </div>

                                    <!-- Occupied row -->
                                    <div class="commissioning-row-label">Occupied</div>
                                    <div class="commissioning-item ${sensor.eo_count === 0 ? 'good' : sensor.eo_count <= 1 ? 'fair' : 'poor'}">
                                        ${sensor.eo_count}
                                    </div>
                                    <div class="commissioning-item ${sensor.lo_count === 0 ? 'good' : sensor.lo_count <= 1 ? 'fair' : 'poor'}">
                                        ${sensor.lo_count}
                                    </div>
                                </div>
                            </td>
                            <td style="width: 10%; text-align: center;">
                                <div class="mini-chart" title="Hourly zone standby percentage over the last 24 hours. Shows daily patterns of building usage and BMS control behavior.">
                                    ${generateMiniChart(sensor.trend_data || Array.from({length: 24}, () => Math.random() * 100))}
                                </div>
                            </td>
                        </tr>
                        <tr class="detail-row" id="detail-${groupIndex}-${index}">
                            <td colspan="7">
                                <div class="detail-content">
                                    <div class="detail-header">Sensor Timeline - ${sensor.sensor_id} / ${sensor.zone_id}</div>
                                    <div class="timeline-section">
                                        <div class="timeline-container" data-timeline-container data-sensor="${sensor.sensor}" data-group="${groupIndex}" data-index="${index}">
                                            <div class="timeline-grid" id="timeline-grid-${groupIndex}-${index}">
                                                <div style="color: #999; padding: 10px; font-size: 12px; text-align: center;">
                                                    <div class="loading">Loading timeline data...</div>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="timeline-info" id="timeline-info-${groupIndex}-${index}">
                                            <!-- Timeline info will be populated by JavaScript -->
                                        </div>
                                        <div class="violations-section" id="violations-section-${groupIndex}-${index}">
                                            <!-- Violations section will be populated by JavaScript -->
                                        </div>
                                    </div>
                                </div>
                            </td>
                        </tr>`).join('')}
                    </tbody>
                `;

                groupContent.appendChild(table);
                container.appendChild(groupContent);
            });
        }

        function toggleGroup(groupIndex) {
            const header = document.querySelectorAll('.group-header')[groupIndex];
            const content = document.getElementById(`group-${groupIndex}`);

            header.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
        }

        function generateMiniChart(data) {
            return data.map((value, index) => {
                const height = (value / 100) * 30;
                const left = (index / data.length) * 100;
                const color = value > 70 ? '#28a745' : value > 50 ? '#ffc107' : '#dc3545';
                return `<div class="chart-bar" style="left: ${left}%; height: ${height}px; background: ${color};"></div>`;
            }).join('');
        }

        async function toggleDetail(groupIndex, sensorIndex, sensorName) {
            const detailRow = document.getElementById(`detail-${groupIndex}-${sensorIndex}`);
            const expandBtn = event.target;

            detailRow.classList.toggle('active');
            expandBtn.classList.toggle('expanded');

            // If expanding and timeline not yet loaded, load it
            if (detailRow.classList.contains('active')) {
                await loadSensorTimeline(groupIndex, sensorIndex, sensorName);
            }
        }

        async function loadSensorTimeline(groupIndex, sensorIndex, sensorName) {
            const timelineGrid = document.getElementById(`timeline-grid-${groupIndex}-${sensorIndex}`);
            const timelineInfo = document.getElementById(`timeline-info-${groupIndex}-${sensorIndex}`);
            const violationsSection = document.getElementById(`violations-section-${groupIndex}-${sensorIndex}`);

            if (!timelineGrid) return;

            // Skip if already loaded (check for timeline rows)
            if (timelineGrid.querySelector('.timeline-row')) {
                return;
            }

            // Show loading state
            timelineGrid.innerHTML = '<div style="color: #999; padding: 10px; font-size: 12px; text-align: center;"><div class="loading">Loading timeline data...</div></div>';

            try {
                if (!sensorName) {
                    throw new Error('Sensor name not provided');
                }

                // Calculate duration based on time period toggle
                let durationHours;
                if (currentTimePeriod === '24h') {
                    durationHours = 24;
                } else if (currentTimePeriod === '5d') {
                    durationHours = 5 * 24; // 120 hours
                } else if (currentTimePeriod === '30d') {
                    durationHours = 5 * 24; // Limited to 5 days for performance
                } else {
                    durationHours = 24; // Default to 24h
                }

                console.log(`ðŸ” [DEBUG] Loading timeline for sensor: ${sensorName}, period: ${currentTimePeriod}, duration: ${durationHours}h`);

                let timelineData;
                if (TOUR_MODE) {
                    // Generate mock timeline data
                    const scenario = TOUR_SCENARIOS[currentTourScenario];
                    timelineData = generateMockTimelineData(sensorName, scenario);
                    console.log(`ðŸ” [DEBUG] Using mock timeline data for scenario: ${currentTourScenario}`);
                } else {
                    // Fetch timeline data from API
                    const response = await fetch(`${API_BASE}/api/sensors/${encodeURIComponent(sensorName)}/timeline?duration_hours=${durationHours}`);

                    if (!response.ok) {
                        throw new Error(`Failed to load timeline: ${response.statusText}`);
                    }

                    timelineData = await response.json();
                }
                console.log(`ðŸ” [DEBUG] Timeline data received:`, timelineData);

                // Generate timeline visualization
                generateTimelineVisualization(timelineGrid, timelineData, groupIndex, sensorIndex);

                // Update timeline info
                updateTimelineInfo(timelineInfo, timelineData);

                // Update violations section
                updateViolationsSection(violationsSection, timelineData, groupIndex, sensorIndex);

            } catch (error) {
                console.error('Error loading timeline:', error);
                timelineGrid.innerHTML = `
                    <div style="color: #dc3545; padding: 10px; font-size: 12px; text-align: center;">
                        Error loading timeline: ${error.message}
                        <br><small>Try selecting a shorter time period or check if sensor data is available.</small>
                    </div>
                `;
            }
        }

        function calculateTimelineRows(events, maxHours = 120) {
            if (!events || events.length === 0) {
                const now = new Date();
                const gridStartTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0); // Start at midnight
                const maxDays = Math.ceil(maxHours / 24);
                return { numRows: maxDays * 3, totalHours: maxHours, gridStartTime, dataStartTime: now, dataEndTime: now };
            }

            // Find actual data time span
            const timestamps = events.map(e => new Date(e.timestamp));
            const dataStartTime = new Date(Math.min(...timestamps));
            const dataEndTime = new Date(Math.max(...timestamps));

            // Hybrid approach: 24h uses current-time-based rolling window, 5d/30d use calendar alignment
            if (maxHours === 24) {
                // For 24h: Use current time minus 24 hours (rolling window)
                const now = new Date();
                const windowStartTime = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                const windowEndTime = now;

                // Find the standard 8-hour blocks that intersect with the 24h window
                // Start from the day containing windowStartTime
                const startDay = new Date(windowStartTime.getFullYear(), windowStartTime.getMonth(), windowStartTime.getDate());
                const endDay = new Date(windowEndTime.getFullYear(), windowEndTime.getMonth(), windowEndTime.getDate() + 1);

                // Calculate which 8-hour blocks intersect with our window
                const blocks = [];
                for (let day = new Date(startDay); day < endDay; day.setDate(day.getDate() + 1)) {
                    for (let slot = 0; slot < 3; slot++) {
                        const blockStart = new Date(day.getTime() + slot * 8 * 60 * 60 * 1000);
                        const blockEnd = new Date(blockStart.getTime() + 8 * 60 * 60 * 1000);

                        // Check if this block intersects with our 24h window
                        if (blockEnd > windowStartTime && blockStart < windowEndTime) {
                            blocks.push({
                                blockStart,
                                blockEnd,
                                dayDate: new Date(day),
                                slot
                            });
                        }
                    }
                }

                const totalHours = 24;
                const numRows = blocks.length;

                return {
                    numRows,
                    totalHours,
                    gridStartTime: windowStartTime,
                    dataStartTime,
                    dataEndTime,
                    gridEndTime: windowEndTime,
                    isRollingWindow: true,
                    windowStartTime,
                    windowEndTime,
                    blocks
                };
            } else {
                // For 5d/30d: Keep calendar day alignment
                // Find the end day (midnight after the last data point)
                const endDayMidnight = new Date(dataEndTime.getFullYear(), dataEndTime.getMonth(), dataEndTime.getDate() + 1, 0, 0, 0);

                // Calculate start time by going back maxHours from end
                const calculatedStartTime = new Date(endDayMidnight.getTime() - maxHours * 60 * 60 * 1000);

                // Align start time to midnight
                const gridStartTime = new Date(calculatedStartTime.getFullYear(), calculatedStartTime.getMonth(), calculatedStartTime.getDate(), 0, 0, 0);

                // Grid end time is the end day midnight
                const gridEndTime = endDayMidnight;

                // Calculate number of days and rows
                const totalDays = Math.ceil((gridEndTime - gridStartTime) / (1000 * 60 * 60 * 24));
                const numRows = totalDays * 3; // 3 rows per day (00:00, 08:00, 16:00)
                const totalHours = (gridEndTime - gridStartTime) / (1000 * 60 * 60);

                return { numRows, totalHours, gridStartTime, dataStartTime, dataEndTime, gridEndTime, isRollingWindow: false };
            }
        }

        function generateTimelineVisualization(timelineGrid, timelineData, groupIndex, sensorIndex) {
            const { events = [], violations = [] } = timelineData;

            // Determine max hours based on current time period
            let maxHours;
            if (currentTimePeriod === '24h') {
                maxHours = 24;
            } else if (currentTimePeriod === '5d') {
                maxHours = 5 * 24; // 120 hours
            } else if (currentTimePeriod === '30d') {
                maxHours = 5 * 24; // Limited to 5 days for performance
            } else {
                maxHours = 24; // Default to 24h
            }

            const { numRows, totalHours, gridStartTime, dataStartTime, dataEndTime, gridEndTime, isRollingWindow, windowStartTime, windowEndTime, blocks } = calculateTimelineRows(events, maxHours);

            console.log(`ðŸ” [DEBUG] Generating ${numRows} timeline rows for ${totalHours.toFixed(1)} hours (grid starts at ${gridStartTime.toISOString()})`);

            // Clear loading message
            timelineGrid.innerHTML = '';

            // Generate timeline rows
            if (isRollingWindow) {
                // For 24h rolling window: Use standard 8-hour blocks that intersect with the window
                let currentDay = null;

                for (let row = 0; row < numRows; row++) {
                    const block = blocks[row];

                    // Add day header when starting a new day
                    const dayKey = block.dayDate.toDateString();
                    if (dayKey !== currentDay) {
                        currentDay = dayKey;
                        const dayHeader = document.createElement('div');
                        dayHeader.className = 'timeline-day-header';

                        const dayName = block.dayDate.toLocaleDateString('en-US', { weekday: 'long' });
                        const dateStr = block.dayDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

                        dayHeader.textContent = `${dayName}, ${dateStr}`;
                        timelineGrid.appendChild(dayHeader);
                    }

                    const timelineRow = document.createElement('div');
                    timelineRow.className = 'timeline-row';

                    // Add row label (standard 8-hour period)
                    const label = document.createElement('div');
                    label.className = 'timeline-row-label';
                    label.textContent = String(block.blockStart.getHours()).padStart(2, '0') + ':00';
                    timelineRow.appendChild(label);

                    // Create timeline container for this row
                    const timeline = document.createElement('div');
                    timeline.className = 'timeline';
                    timeline.dataset.row = row;

                    // Add events for this 8-hour period, filtered to the 24h window
                    addEventsToGridTimelineRowWithWindow(timeline, events, violations, block.blockStart, windowStartTime, windowEndTime);

                    timelineRow.appendChild(timeline);
                    timelineGrid.appendChild(timelineRow);
                }
            } else {
                // For 5d/30d: Use calendar day alignment (original logic)
                let currentDayIndex = -1;
                for (let row = 0; row < numRows; row++) {
                    // Calculate row time based on fixed 8-hour schedule
                    const dayIndex = Math.floor(row / 3);
                    const timeSlot = row % 3;
                    const rowStartHour = timeSlot * 8; // 0, 8, or 16
                    const rowDate = new Date(gridStartTime.getTime() + dayIndex * 24 * 60 * 60 * 1000 + rowStartHour * 60 * 60 * 1000);

                    // Add day header when starting a new day
                    if (dayIndex !== currentDayIndex) {
                        currentDayIndex = dayIndex;
                        const dayHeader = document.createElement('div');
                        dayHeader.className = 'timeline-day-header';

                        const dayDate = new Date(gridStartTime.getTime() + dayIndex * 24 * 60 * 60 * 1000);
                        const dayName = dayDate.toLocaleDateString('en-US', { weekday: 'long' });
                        const dateStr = dayDate.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

                        dayHeader.textContent = `${dayName}, ${dateStr}`;
                        timelineGrid.appendChild(dayHeader);
                    }

                    const timelineRow = document.createElement('div');
                    timelineRow.className = 'timeline-row';

                    // Add row label (time only, since day is in header)
                    const label = document.createElement('div');
                    label.className = 'timeline-row-label';
                    label.textContent = String(rowDate.getHours()).padStart(2, '0') + ':00';
                    timelineRow.appendChild(label);

                    // Create timeline container for this row
                    const timeline = document.createElement('div');
                    timeline.className = 'timeline';
                    timeline.dataset.row = row;

                    // Add events for this 8-hour period
                    addEventsToGridTimelineRow(timeline, events, violations, rowDate);

                    timelineRow.appendChild(timeline);
                    timelineGrid.appendChild(timelineRow);
                }
            }

            // Add hover functionality
            addTimelineLoupeHover(timelineGrid, events, violations, gridStartTime);
        }

        function addEventsToGridTimelineRow(timeline, events, violations, rowDate) {
            const rowStartTime = new Date(rowDate);
            const rowEndTime = new Date(rowStartTime.getTime() + 8 * 60 * 60 * 1000); // 8 hours later

            // Filter events for this row's time period
            const rowEvents = events.filter(event => {
                const eventTime = new Date(event.timestamp);
                return eventTime >= rowStartTime && eventTime < rowEndTime;
            });

            const rowViolations = violations.filter(violation => {
                const violationTime = new Date(violation.timestamp);
                return violationTime >= rowStartTime && violationTime < rowEndTime;
            });

            // Add sensor and zone events
            rowEvents.forEach(event => {
                const eventElement = document.createElement('div');
                const eventTime = new Date(event.timestamp);
                const minutesFromRowStart = (eventTime - rowStartTime) / (1000 * 60);
                const xPos = (minutesFromRowStart / (8 * 60)) * 100; // Position within 8-hour row

                eventElement.className = `event ${event.type} ${event.value === 1 ? (event.type === 'sensor' ? 'occupied' : 'standby') : (event.type === 'sensor' ? 'unoccupied' : 'occupied')}`;
                eventElement.style.left = `${Math.max(0, Math.min(100, xPos))}%`;
                eventElement.title = `${event.timestamp}: ${event.description || event.type}`;

                timeline.appendChild(eventElement);
            });

            // Add violations
            rowViolations.forEach(violation => {
                const violationElement = document.createElement('div');
                const violationTime = new Date(violation.timestamp);
                const minutesFromRowStart = (violationTime - rowStartTime) / (1000 * 60);
                const xPos = (minutesFromRowStart / (8 * 60)) * 100;

                violationElement.className = 'violation';
                violationElement.style.left = `${Math.max(0, Math.min(100, xPos))}%`;
                violationElement.title = `Violation: ${violation.description || violation.type}`;

                timeline.appendChild(violationElement);
            });
        }

        function addEventsToGridTimelineRowWithWindow(timeline, events, violations, rowDate, windowStartTime, windowEndTime) {
            const rowStartTime = new Date(rowDate);
            const rowEndTime = new Date(rowStartTime.getTime() + 8 * 60 * 60 * 1000); // 8 hours later

            // Filter events for this row's time period AND within the 24h window
            const rowEvents = events.filter(event => {
                const eventTime = new Date(event.timestamp);
                return eventTime >= rowStartTime && eventTime < rowEndTime &&
                       eventTime >= windowStartTime && eventTime < windowEndTime;
            });

            const rowViolations = violations.filter(violation => {
                const violationTime = new Date(violation.timestamp);
                return violationTime >= rowStartTime && violationTime < rowEndTime &&
                       violationTime >= windowStartTime && violationTime < windowEndTime;
            });

            // Add sensor and zone events
            rowEvents.forEach(event => {
                const eventElement = document.createElement('div');
                const eventTime = new Date(event.timestamp);
                const minutesFromRowStart = (eventTime - rowStartTime) / (1000 * 60);
                const xPos = (minutesFromRowStart / (8 * 60)) * 100; // Position within 8-hour row

                eventElement.className = `event ${event.type} ${event.value === 1 ? (event.type === 'sensor' ? 'occupied' : 'standby') : (event.type === 'sensor' ? 'unoccupied' : 'occupied')}`;
                eventElement.style.left = `${Math.max(0, Math.min(100, xPos))}%`;
                eventElement.title = `${event.timestamp}: ${event.description || event.type}`;

                timeline.appendChild(eventElement);
            });

            // Add violations
            rowViolations.forEach(violation => {
                const violationElement = document.createElement('div');
                const violationTime = new Date(violation.timestamp);
                const minutesFromRowStart = (violationTime - rowStartTime) / (1000 * 60);
                const xPos = (minutesFromRowStart / (8 * 60)) * 100;

                violationElement.className = 'violation';
                violationElement.style.left = `${Math.max(0, Math.min(100, xPos))}%`;
                violationElement.title = `Violation: ${violation.description || violation.type}`;

                timeline.appendChild(violationElement);
            });
        }

        function updateTimelineInfo(timelineInfo, timelineData) {
            if (!timelineInfo) return;

            const { events = [], violations = [] } = timelineData;
            const sensorEvents = events.filter(e => e.type === 'sensor').length;
            const zoneEvents = events.filter(e => e.type === 'zone').length;

            // Determine max hours based on current time period
            let maxHours;
            if (currentTimePeriod === '24h') {
                maxHours = 24;
            } else if (currentTimePeriod === '5d') {
                maxHours = 5 * 24; // 120 hours
            } else if (currentTimePeriod === '30d') {
                maxHours = 5 * 24; // Limited to 5 days for performance
            } else {
                maxHours = 24; // Default to 24h
            }

            const { totalHours, gridStartTime, dataStartTime, dataEndTime } = calculateTimelineRows(events, maxHours);

            timelineInfo.innerHTML = `
                Events: ${sensorEvents} sensor, ${zoneEvents} zone |
                Grid Duration: ${totalHours.toFixed(1)} hours (${gridStartTime.toLocaleDateString()} 00:00 - ${new Date(gridStartTime.getTime() + totalHours * 60 * 60 * 1000).toLocaleDateString()})
                ${totalHours >= 120 ? ' <span style="color: #856404;">(Limited to 5 days for performance)</span>' : ''}
            `;
        }

        function updateViolationsSection(violationsSection, timelineData, groupIndex, sensorIndex) {
            if (!violationsSection) return;

            const { violations = [] } = timelineData;

            // Get sensor and zone names from timeline data
            let sensorName = timelineData.sensor || 'Unknown Sensor';
            let zoneName = timelineData.zone || 'Unknown Zone';

            console.log('ðŸ” [DEBUG] Timeline data keys:', Object.keys(timelineData));
            console.log('ðŸ” [DEBUG] Extracted names - Sensor:', sensorName, 'Zone:', zoneName);

            // Store violations data for CSV export
            const sensorKey = `${groupIndex}-${sensorIndex}`;
            violationsData[sensorKey] = { violations, timelineData, sensorName, zoneName };

            if (violations.length === 0) {
                violationsSection.innerHTML = '<div style="color: #28a745; font-size: 0.9em; padding: 8px;">âœ“ No out of spec mode changes detected</div>';
                return;
            }

            // Separate violations by type
            const standbyViolations = violations.filter(v => v.type?.includes('standby') || v.description?.includes('standby'));
            const occupiedViolations = violations.filter(v => v.type?.includes('occupied') || v.description?.includes('occupied'));
            const otherViolations = violations.filter(v => !standbyViolations.includes(v) && !occupiedViolations.includes(v));

            const containerId = `${groupIndex}-${sensorIndex}`;

            violationsSection.innerHTML = `
                <div class="collapsible-header" onclick="toggleViolations('${containerId}')" title="Click to expand/collapse timing details">
                    <span><strong>Out of spec mode changes (${violations.length})</strong></span>
                    <span style="display: flex; align-items: center; gap: 10px;">
                        ${violations.length > 0 ? `<a href="#" onclick="downloadOutOfSpecCSV('${groupIndex}-${sensorIndex}'); return false;" style="font-size: 0.8em; color: #007bff; text-decoration: none;">Download all to CSV</a>` : ''}
                        <span id="toggle-${containerId}">+</span>
                    </span>
                </div>
                <div class="collapsible-content collapsed" id="violations-${containerId}">
                    <div class="violations-columns">
                        <div class="violation-column">
                            <div class="violation-column-header">Occupied â†’ Standby (${standbyViolations.length})</div>
                            <div style="font-size: 0.75em; color: #666; margin-bottom: 8px;">Zone switched to standby before 15-minute delay</div>
                            ${standbyViolations.slice(-8).map(v => `
                                <div class="violation-item">
                                    ${new Date(v.timestamp).toLocaleTimeString()} - ${v.message ? v.message.replace('Early standby transition after ', '') : (v.description || v.type)}
                                </div>
                            `).join('')}
                            ${standbyViolations.length > 8 ? `<div style="font-style: italic; font-size: 0.75em; padding: 4px;">... and ${standbyViolations.length - 8} more</div>` : ''}
                        </div>
                        <div class="violation-column">
                            <div class="violation-column-header">Standby â†’ Occupied (${occupiedViolations.length})</div>
                            <div style="font-size: 0.75em; color: #666; margin-bottom: 8px;">Zone activated before 5-minute delay</div>
                            ${occupiedViolations.slice(-8).map(v => `
                                <div class="violation-item">
                                    ${new Date(v.timestamp).toLocaleTimeString()} - ${v.message ? v.message.replace('Early occupied transition after ', '') : (v.description || v.type)}
                                </div>
                            `).join('')}
                            ${occupiedViolations.length > 8 ? `<div style="font-style: italic; font-size: 0.75em; padding: 4px;">... and ${occupiedViolations.length - 8} more</div>` : ''}
                        </div>
                    </div>
                    ${otherViolations.length > 0 ? `
                        <div class="violation-column" style="grid-column: 1 / -1; margin-top: 8px;">
                            <div class="violation-column-header">Other Violations (${otherViolations.length})</div>
                            ${otherViolations.slice(-8).map(v => `
                                <div class="violation-item">
                                    ${new Date(v.timestamp).toLocaleTimeString()} - ${v.description || v.type}
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function toggleViolations(containerId) {
            const content = document.getElementById(`violations-${containerId}`);
            const toggle = document.getElementById(`toggle-${containerId}`);

            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.classList.add('expanded');
                toggle.textContent = 'âˆ’';
            } else {
                content.classList.remove('expanded');
                content.classList.add('collapsed');
                toggle.textContent = '+';
            }
        }

        function downloadOutOfSpecCSV(sensorKey) {
            const data = violationsData[sensorKey];
            if (!data || !data.violations || data.violations.length === 0) {
                alert('No out of spec mode changes data available for download.');
                return;
            }

            const { violations, timelineData, sensorName, zoneName } = data;

            // CSV headers
            const headers = [
                'Date',
                'Time',
                'Out of Spec Type',
                'Duration'
            ];

            // Helper function to extract duration from message and convert to HH:MM:SS
            function extractDuration(message) {
                if (!message) return '';

                // Extract duration from messages like "Early standby transition after 17s" or "Early standby transition after 2min 17s"
                const match = message.match(/after\s+(.+?)$/i);
                if (!match) return message;

                const durationStr = match[1].trim();

                // Parse various time formats and convert to total seconds
                let totalSeconds = 0;

                // Match patterns like "2min 17s", "17s", "1h 30min", etc.
                const hourMatch = durationStr.match(/(\d+)h(?:our)?s?/i);
                const minMatch = durationStr.match(/(\d+)min(?:ute)?s?/i);
                const secMatch = durationStr.match(/(\d+)s(?:ec(?:ond)?s?)?(?:\s|$)/i);

                if (hourMatch) totalSeconds += parseInt(hourMatch[1]) * 3600;
                if (minMatch) totalSeconds += parseInt(minMatch[1]) * 60;
                if (secMatch) totalSeconds += parseInt(secMatch[1]);

                // If no pattern matched, try to parse as pure number (assume seconds)
                if (totalSeconds === 0) {
                    const numMatch = durationStr.match(/^(\d+)$/);
                    if (numMatch) {
                        totalSeconds = parseInt(numMatch[1]);
                    } else {
                        return durationStr; // Return original if can't parse
                    }
                }

                // Convert to HH:MM:SS format
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;

                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            // Convert violations to CSV rows
            const rows = violations.map(violation => {
                const timestamp = new Date(violation.timestamp);
                return [
                    timestamp.toLocaleDateString(),
                    timestamp.toLocaleTimeString(),
                    violation.type || '',
                    extractDuration(violation.message)
                ].map(field => `"${String(field).replace(/"/g, '""')}"`); // Escape quotes
            });

            // Combine headers and rows
            const csvContent = [headers.join(','), ...rows.map(row => row.join(','))].join('\n');

            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');

            const customerName = document.getElementById('customerName').value.trim() || 'ODCV';
            const currentDate = new Date().toISOString().split('T')[0];
            const sensorClean = (sensorName || 'Unknown_Sensor').replace(/[^a-zA-Z0-9]/g, '_');
            const zoneClean = (zoneName || 'Unknown_Zone').replace(/[^a-zA-Z0-9]/g, '_');
            const filename = `${customerName}_out_of_spec_mode_changes_${sensorClean}_${zoneClean}_${currentDate}.csv`;

            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function addTimelineLoupeHover(timelineGrid, events, violations, startTime) {
            const loupe = document.getElementById('zoom-loupe');
            const loupeHeader = document.getElementById('zoom-header');
            const loupeTimeline = document.getElementById('zoom-timeline');

            timelineGrid.addEventListener('mousemove', (e) => {
                const rect = timelineGrid.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Determine which row we're hovering over
                const timelineRows = timelineGrid.querySelectorAll('.timeline-row');
                let activeRow = 0;
                let rowY = 0;

                for (let i = 0; i < timelineRows.length; i++) {
                    const rowRect = timelineRows[i].getBoundingClientRect();
                    const relativeY = e.clientY - rowRect.top;
                    if (relativeY >= 0 && relativeY <= rowRect.height) {
                        activeRow = i;
                        rowY = relativeY;
                        break;
                    }
                }

                // Calculate time position within the row
                const rowWidth = rect.width;
                const xPercent = (x / rowWidth) * 100;
                const minutesIntoRow = (xPercent / 100) * (8 * 60); // 8 hours = 480 minutes
                const rowStartTime = new Date(startTime.getTime() + activeRow * 8 * 60 * 60 * 1000);
                const hoverTime = new Date(rowStartTime.getTime() + minutesIntoRow * 60 * 1000);

                // Show loupe with smart positioning
                loupe.classList.add('visible');

                // Smart flip positioning to avoid viewport overflow
                const loupeWidth = 600; // loupe width in pixels
                const margin = 20; // margin from cursor
                const viewportWidth = window.innerWidth;

                let leftPos;
                if (e.clientX + loupeWidth + margin > viewportWidth) {
                    // Position to left of cursor when near right edge
                    leftPos = e.clientX - loupeWidth - margin;
                    // Ensure we don't go negative
                    leftPos = Math.max(margin, leftPos);
                } else {
                    // Normal position to right of cursor
                    leftPos = e.clientX + margin;
                }

                loupe.style.left = `${leftPos}px`;
                loupe.style.top = `${e.clientY - 45}px`;

                // Update header with time
                const hours = hoverTime.getHours().toString().padStart(2, '0');
                const minutes = hoverTime.getMinutes().toString().padStart(2, '0');
                loupeHeader.textContent = `${hoverTime.toLocaleDateString()} ${hours}:${minutes} - 2hr window`;

                // Generate zoomed timeline content
                generateLoupeContent(loupeTimeline, events, violations, hoverTime);
            });

            timelineGrid.addEventListener('mouseleave', () => {
                loupe.classList.remove('visible');
            });
        }

        function generateLoupeContent(loupeTimeline, events, violations, centerTime) {
            // Clear existing content
            loupeTimeline.innerHTML = '';

            // 2-hour window (1 hour before and after)
            const windowStart = new Date(centerTime.getTime() - 60 * 60 * 1000);
            const windowEnd = new Date(centerTime.getTime() + 60 * 60 * 1000);

            // Filter events within the window
            const windowEvents = events.filter(event => {
                const eventTime = new Date(event.timestamp);
                return eventTime >= windowStart && eventTime <= windowEnd;
            });

            const windowViolations = violations.filter(violation => {
                const violationTime = new Date(violation.timestamp);
                return violationTime >= windowStart && violationTime <= windowEnd;
            });

            // Add events to loupe
            windowEvents.forEach(event => {
                const eventElement = document.createElement('div');
                const eventTime = new Date(event.timestamp);
                const minutesFromStart = (eventTime - windowStart) / (1000 * 60);
                const xPos = (minutesFromStart / 120) * 100; // 2-hour window

                eventElement.className = `zoom-event ${event.type} ${event.value === 1 ? (event.type === 'sensor' ? 'occupied' : 'standby') : (event.type === 'sensor' ? 'unoccupied' : 'occupied')}`;
                eventElement.style.left = `${Math.max(0, Math.min(100, xPos))}%`;
                eventElement.title = `${event.timestamp}: ${event.description || event.type}`;

                loupeTimeline.appendChild(eventElement);
            });

            // Add violations to loupe
            windowViolations.forEach(violation => {
                const violationElement = document.createElement('div');
                const violationTime = new Date(violation.timestamp);
                const minutesFromStart = (violationTime - windowStart) / (1000 * 60);
                const xPos = (minutesFromStart / 120) * 100;

                violationElement.className = 'zoom-violation';
                violationElement.style.left = `${Math.max(0, Math.min(100, xPos))}%`;
                violationElement.title = `Violation: ${violation.description || violation.type}`;

                loupeTimeline.appendChild(violationElement);
            });
        }

        function setTimePeriod(period) {
            console.log(`ðŸ• [DEBUG] Setting time period from ${currentTimePeriod} to ${period}`);

            // Update toggle buttons
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update current time period and reload data
            const previousPeriod = currentTimePeriod;
            currentTimePeriod = period;
            console.log(`âœ… [DEBUG] Time period changed: ${previousPeriod} â†’ ${period}`);

            // Show loading state immediately
            document.getElementById('executive-dashboard').innerHTML =
                `<div class="loading">Loading ${period} data... This may take a moment for longer periods.</div>`;

            // Reload all dashboard data with new time period
            console.log(`ðŸ”„ [DEBUG] Reloading dashboard data for period: ${period}`);
            loadDashboardData();
        }

        // Initialize the page
        document.addEventListener('DOMContentLoaded', async () => {
            if (TOUR_MODE) {
                // In tour mode, automatically load the default scenario
                await loadTourScenario();
                // Also initialize dataset info display in tour mode
                startDatasetInfoUpdates();
                // Auto-start the guided tour
                setTimeout(() => {
                    startGuidedTour();
                }, 1000); // Small delay to ensure page is fully loaded
            } else {
                // Start dataset info monitoring
                startDatasetInfoUpdates();

                // Check if we have any data on startup
                fetch(`${API_BASE}/api/sensors`)
                    .then(response => response.json())
                    .then(sensors => {
                        if (sensors.length > 0) {
                            loadDashboardData();
                        }
                    })
                    .catch(error => {
                        console.log('No initial data available');
                    });
            }
        });

        // ===== GUIDED TOUR SYSTEM =====

        // Tour configuration
        let currentTourStep = 0;
        let tourActive = false;

        const tourSteps = [
            {
                target: '.header',
                title: 'Welcome to Live ODCV Analytics',
                content: 'You\'re now viewing a live demonstration of the ODCV Analytics Dashboard. This system analyzes occupancy sensor data and zone control logic to validate Building Management System timing compliance. Watch as we demonstrate real validation scenarios with interactive features.'
            },
            {
                target: '#tourScenario',
                title: 'Automatic Scenario Switching',
                content: 'The tour is now switching to the "Data Gaps" scenario to demonstrate missing sensor data detection. Notice how the scenario selector highlights and the metrics update automatically.',
                action: 'autoSwitchToDataGaps'
            },
            {
                target: '.dashboard-grid',
                title: 'Live Metrics Dashboard',
                content: 'The metrics are updating in real-time! You\'re seeing Data Quality % drop (indicating missing data), Correlation Health scores change, and Standby Mode % reflecting actual energy performance. The red indicators highlight validation problems.',
                action: 'highlightMetrics'
            },
            {
                target: '#tourScenario',
                title: 'Switching to Severe Divergence',
                content: 'Now demonstrating severe sensor/VAV divergence scenario. Watch the correlation scores drop and validation metrics change as we switch to show poor BMS synchronization.',
                action: 'autoSwitchToSevereDivergence'
            },
            {
                target: '.grouped-container',
                title: 'Room Validation Results',
                content: 'Each row shows live validation results: sensor quality, correlation scores, missing data percentages, and timing violations. Red indicators pinpoint rooms with BMS issues. You can see the data refreshing based on the current scenario.',
                action: 'autoExpandFirstRoom'
            },
            {
                target: '.sensor-detail-row',
                title: 'Live Timeline View',
                content: 'The tour has expanded a room to show you the detailed validation timeline. You can see sensor occupancy (green), VAV control states (blue), and timing violations (red markers). This reveals exactly when and how BMS validation issues occur.',
                action: 'openAndHighlightTimeline'
            },
            {
                target: 'body',
                title: 'Interactive Dashboard Ready!',
                content: 'You\'ve experienced live automated demonstrations of BMS validation. The dashboard is fully interactive - try switching scenarios manually, expanding other rooms, or exit the tour to explore all features freely. Each scenario tells a different validation story.'
            }
        ];

        function startGuidedTour() {
            if (tourActive) return;

            tourActive = true;
            currentTourStep = 0;

            // Open tour in a popup window
            const tourWindow = window.open('', 'tourWindow', 'width=450,height=600,scrollbars=no,resizable=yes,menubar=no,toolbar=no,location=no,status=no');
            window.tourWindow = tourWindow;

            // Create the tour interface in the popup
            tourWindow.document.write(createTourWindowContent());
            tourWindow.document.close();

            // Start first step
            showTourStep(0);

            // Add keyboard listeners to main window
            document.addEventListener('keydown', handleTourKeyboard);

            // Handle popup close
            tourWindow.onbeforeunload = function() {
                exitTour();
            };
        }

        function createTourWindowContent() {
            return `
<!DOCTYPE html>
<html>
<head>
    <title>Interactive Tour - ODCV Analytics</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .tour-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.1);
        }

        .tour-header h2 {
            margin: 0 0 8px 0;
            font-size: 20px;
            font-weight: 600;
        }

        .tour-header p {
            margin: 0;
            opacity: 0.9;
            font-size: 14px;
        }

        .tour-content {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .tour-step-counter {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 20px;
            width: fit-content;
            align-self: center;
        }

        .tour-step-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .tour-step-content {
            font-size: 14px;
            line-height: 1.6;
            opacity: 0.95;
            flex: 1;
            margin-bottom: 20px;
        }

        .tour-navigation {
            display: flex;
            gap: 12px;
            margin-top: auto;
        }

        .tour-nav-btn {
            flex: 1;
            padding: 12px 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .tour-nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .tour-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tour-exit-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px 10px;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .tour-exit-btn:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <button class="tour-exit-btn" onclick="window.close()">Ã—</button>

    <div class="tour-header">
        <h2>Interactive Tour</h2>
        <p>ODCV Analytics Dashboard</p>
    </div>

    <div class="tour-content">
        <div class="tour-step-counter" id="tourStepCounter">Step 1 of 7</div>
        <div class="tour-step-title" id="tourTitle">Welcome to the Dashboard</div>
        <div class="tour-step-content" id="tourContent">This is the content of the tour step.</div>

        <div class="tour-navigation">
            <button class="tour-nav-btn" id="tourPrevBtn" onclick="window.opener.previousTourStep()">Previous</button>
            <button class="tour-nav-btn" id="tourNextBtn" onclick="window.opener.nextTourStep()">Next</button>
        </div>
    </div>
</body>
</html>`;
        }

        function exitTour() {
            tourActive = false;

            // Close popup window if it exists
            if (window.tourWindow && !window.tourWindow.closed) {
                window.tourWindow.close();
            }
            window.tourWindow = null;

            // Remove keyboard listeners
            document.removeEventListener('keydown', handleTourKeyboard);

            // Reset any expanded elements
            resetTourState();
        }

        function nextTourStep() {
            if (currentTourStep < tourSteps.length - 1) {
                currentTourStep++;
                showTourStep(currentTourStep);
            } else {
                exitTour();
            }
        }

        function previousTourStep() {
            if (currentTourStep > 0) {
                currentTourStep--;
                showTourStep(currentTourStep);
            }
        }

        function showTourStep(stepIndex) {
            const step = tourSteps[stepIndex];
            if (!step) return;

            // Execute step action if any
            if (step.action) {
                executeStepAction(step.action);
            }

            // Update popup window content if it exists
            if (window.tourWindow && !window.tourWindow.closed) {
                const tourDoc = window.tourWindow.document;

                // Update step counter
                const stepCounter = tourDoc.getElementById('tourStepCounter');
                if (stepCounter) {
                    stepCounter.textContent = `Step ${stepIndex + 1} of ${tourSteps.length}`;
                }

                // Update content
                const titleElement = tourDoc.getElementById('tourTitle');
                const contentElement = tourDoc.getElementById('tourContent');
                if (titleElement) titleElement.textContent = step.title;
                if (contentElement) contentElement.textContent = step.content;

                // Update navigation buttons
                const prevBtn = tourDoc.getElementById('tourPrevBtn');
                const nextBtn = tourDoc.getElementById('tourNextBtn');

                if (prevBtn) prevBtn.disabled = stepIndex === 0;
                if (nextBtn) nextBtn.textContent = stepIndex === tourSteps.length - 1 ? 'Finish' : 'Next';
            }

            // Highlight target element in main window
            setTimeout(() => {
                highlightTourTarget(step);
            }, 100);
        }

        function positionTourElements(step) {
            const highlight = document.getElementById('tourHighlight');
            const tooltip = document.getElementById('tourTooltip');

            // Find target element
            let targetElement;
            if (step.target === 'body') {
                // Center position for body target
                highlight.style.display = 'none';
                tooltip.style.left = '50%';
                tooltip.style.top = '50%';
                tooltip.style.transform = 'translate(-50%, -50%)';
                tooltip.classList.add('active');
                return;
            } else {
                targetElement = document.querySelector(step.target);
            }

            if (!targetElement) {
                console.warn('Tour target not found:', step.target);
                return;
            }

            // Get element position
            const rect = targetElement.getBoundingClientRect();
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

            // Position highlight
            highlight.style.display = 'block';
            highlight.style.left = (rect.left + scrollLeft - 8) + 'px';
            highlight.style.top = (rect.top + scrollTop - 8) + 'px';
            highlight.style.width = (rect.width + 16) + 'px';
            highlight.style.height = (rect.height + 16) + 'px';

            // Position tooltip
            let tooltipLeft, tooltipTop;

            switch (step.position) {
                case 'top':
                    tooltipLeft = rect.left + scrollLeft + (rect.width / 2) - 200;
                    tooltipTop = rect.top + scrollTop - 200;
                    break;
                case 'bottom':
                    tooltipLeft = rect.left + scrollLeft + (rect.width / 2) - 200;
                    tooltipTop = rect.bottom + scrollTop + 20;
                    break;
                case 'left':
                    tooltipLeft = rect.left + scrollLeft - 420;
                    tooltipTop = rect.top + scrollTop + (rect.height / 2) - 100;
                    break;
                case 'right':
                    tooltipLeft = rect.right + scrollLeft + 20;
                    tooltipTop = rect.top + scrollTop + (rect.height / 2) - 100;
                    break;
                default:
                    tooltipLeft = rect.left + scrollLeft + (rect.width / 2) - 200;
                    tooltipTop = rect.bottom + scrollTop + 20;
            }

            // Ensure tooltip stays within viewport
            tooltipLeft = Math.max(20, Math.min(tooltipLeft, window.innerWidth - 420));
            tooltipTop = Math.max(20, tooltipTop);

            tooltip.style.left = tooltipLeft + 'px';
            tooltip.style.top = tooltipTop + 'px';
            tooltip.style.transform = 'none';

            // Scroll element into view
            targetElement.scrollIntoView({
                behavior: 'smooth',
                block: 'center'
            });

            // Show tooltip
            setTimeout(() => {
                tooltip.classList.add('active');
            }, 200);
        }

        function generateTourProgress() {
            const progressContainer = document.getElementById('tourProgress');
            progressContainer.innerHTML = '';

            for (let i = 0; i < tourSteps.length; i++) {
                const dot = document.createElement('div');
                dot.className = 'tour-progress-dot';
                if (i === 0) dot.classList.add('active');
                progressContainer.appendChild(dot);
            }
        }

        function updateTourProgress(currentStep) {
            const dots = document.querySelectorAll('.tour-progress-dot');
            dots.forEach((dot, index) => {
                dot.classList.remove('active', 'completed');
                if (index < currentStep) {
                    dot.classList.add('completed');
                } else if (index === currentStep) {
                    dot.classList.add('active');
                }
            });
        }

        function executeStepAction(action) {
            switch (action) {
                case 'expandFirstSensor':
                    // Find and click the first sensor row to expand timeline
                    setTimeout(() => {
                        const firstSensorRow = document.querySelector('.sensor-row');
                        if (firstSensorRow) {
                            firstSensorRow.click();
                        }
                    }, 500);
                    break;
                case 'autoSwitchToDataGaps':
                    autoSwitchScenario('data_gaps');
                    break;
                case 'autoSwitchToSevereDivergence':
                    autoSwitchScenario('severe_divergence');
                    break;
                case 'autoSwitchToMildDivergence':
                    autoSwitchScenario('mild_divergence');
                    break;
                case 'autoExpandFirstRoom':
                    autoExpandFirstRoom();
                    break;
                case 'highlightMetrics':
                    highlightElement('.dashboard-grid');
                    break;
                case 'highlightTimeline':
                    highlightElement('.timeline-container');
                    break;
                case 'openAndHighlightTimeline':
                    openAndHighlightTimeline();
                    break;
            }
        }

        function resetTourState() {
            // Close any expanded sensor rows
            const expandedRows = document.querySelectorAll('.sensor-detail-row.active');
            expandedRows.forEach(row => {
                row.classList.remove('active');
                row.style.display = 'none';
            });

            // Remove any tour highlights
            const existingHighlights = document.querySelectorAll('.tour-auto-highlight');
            existingHighlights.forEach(highlight => highlight.remove());
        }

        // ===== AUTOMATED TOUR FUNCTIONS =====

        function autoSwitchScenario(scenarioKey) {
            const scenarioSelect = document.getElementById('tourScenario');
            if (scenarioSelect) {
                // Add visual feedback
                highlightElement('#tourScenario', 'Switching to ' + scenarioKey.replace('_', ' ') + ' scenario...');

                setTimeout(() => {
                    scenarioSelect.value = scenarioKey;
                    scenarioSelect.dispatchEvent(new Event('change'));

                    // Brief highlight after change
                    setTimeout(() => {
                        addAutoHighlight('#executive-dashboard', 2000);
                    }, 500);
                }, 1000);
            }
        }

        function autoExpandFirstRoom() {
            // Find the first room row and expand it
            setTimeout(() => {
                const firstSensorRow = document.querySelector('.sensor-row');
                if (firstSensorRow) {
                    highlightElement('.sensor-row', 'Expanding room details...');

                    setTimeout(() => {
                        firstSensorRow.click();

                        // Highlight the timeline after expansion
                        setTimeout(() => {
                            addAutoHighlight('.timeline-container', 3000);
                        }, 500);
                    }, 1000);
                }
            }, 500);
        }

        function openAndHighlightTimeline() {
            // Ensure timeline is visible and highlighted for step 6
            setTimeout(() => {
                // First ensure the sensor detail row is active (should be from step 5)
                const sensorDetailRow = document.querySelector('.sensor-detail-row.active');
                if (sensorDetailRow) {
                    // Scroll the timeline into view
                    const timelineContainer = sensorDetailRow.querySelector('.timeline-container');
                    if (timelineContainer) {
                        timelineContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });

                        // Add enhanced highlighting for the timeline
                        setTimeout(() => {
                            addAutoHighlight('.timeline-container', 4000);

                            // Additional highlight for specific timeline elements
                            setTimeout(() => {
                                addAutoHighlight('.timeline-chart svg', 2000);
                            }, 1000);
                        }, 500);
                    }
                } else {
                    // Fallback: just highlight any timeline container
                    highlightElement('.timeline-container', 'Timeline view');
                }
            }, 300);
        }

        function highlightElement(selector, message = '') {
            // Add a temporary highlight to an element
            const element = document.querySelector(selector);
            if (element) {
                const highlight = document.createElement('div');
                highlight.className = 'tour-auto-highlight';
                highlight.style.cssText = `
                    position: absolute;
                    pointer-events: none;
                    border: 3px solid #667eea;
                    border-radius: 8px;
                    background: rgba(102, 126, 234, 0.1);
                    z-index: 10000;
                    transition: all 0.3s ease;
                    animation: pulse 2s infinite;
                `;

                // Position the highlight
                const rect = element.getBoundingClientRect();
                highlight.style.left = (rect.left - 5) + 'px';
                highlight.style.top = (rect.top - 5) + 'px';
                highlight.style.width = (rect.width + 10) + 'px';
                highlight.style.height = (rect.height + 10) + 'px';

                document.body.appendChild(highlight);

                // Add message if provided
                if (message) {
                    const messageDiv = document.createElement('div');
                    messageDiv.style.cssText = `
                        position: absolute;
                        top: ${rect.top - 40}px;
                        left: ${rect.left}px;
                        background: #667eea;
                        color: white;
                        padding: 5px 10px;
                        border-radius: 4px;
                        font-size: 12px;
                        z-index: 10001;
                        white-space: nowrap;
                    `;
                    messageDiv.textContent = message;
                    messageDiv.className = 'tour-auto-highlight';
                    document.body.appendChild(messageDiv);
                }

                // Remove after 3 seconds
                setTimeout(() => {
                    const highlights = document.querySelectorAll('.tour-auto-highlight');
                    highlights.forEach(h => {
                        if (h === highlight || (message && h.textContent === message)) {
                            h.remove();
                        }
                    });
                }, 3000);
            }
        }

        function addAutoHighlight(selector, duration = 2000) {
            const element = document.querySelector(selector);
            if (element) {
                element.style.boxShadow = '0 0 20px rgba(102, 126, 234, 0.8)';
                element.style.transition = 'box-shadow 0.3s ease';

                setTimeout(() => {
                    element.style.boxShadow = '';
                }, duration);
            }
        }

        function handleTourKeyboard(event) {
            if (!tourActive) return;

            switch (event.key) {
                case 'ArrowRight':
                case ' ':
                    event.preventDefault();
                    nextTourStep();
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    previousTourStep();
                    break;
                case 'Escape':
                    event.preventDefault();
                    exitTour();
                    break;
            }
        }
    </script>

    <!-- Zoom Loupe -->
    <div class="zoom-loupe" id="zoom-loupe">
        <div class="zoom-header" id="zoom-header">Hover View</div>
        <div class="zoom-content">
            <div class="zoom-timeline" id="zoom-timeline"></div>
            <div class="zoom-labels">
                <div class="sensor-label">Sensor</div>
                <div class="zone-label">Zone</div>
            </div>
        </div>
    </div>

    <!-- Test Datasets Section -->
    <div class="upload-section" style="margin-top: 40px; border-top: 2px solid #dee2e6; padding-top: 30px;">
        <h3>Test Datasets</h3>
        <p style="margin-bottom: 20px; color: #666; font-size: 0.9em;">These datasets are for testing and demonstration purposes only.</p>

        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
            <button class="upload-btn" onclick="loadPresetDataset('SCH-1_data_30_days_mock')">
                30 Days / 100 Sensors (Mock)
                <div style="font-size: 0.8em; opacity: 0.8;">Full dataset with BV zones</div>
            </button>
            <button class="upload-btn" onclick="loadPresetDataset('SCH-1_data_5_days_mock')">
                5 Days / 100 Sensors (Mock)
                <div style="font-size: 0.8em; opacity: 0.8;">Medium dataset with BV zones</div>
            </button>
            <button class="upload-btn" onclick="loadPresetDataset('SCH-1_data_1_day_mock')">
                1 Day / 100 Sensors (Mock)
                <div style="font-size: 0.8em; opacity: 0.8;">Quick test dataset</div>
            </button>
            <button class="upload-btn" onclick="loadPresetDataset('SCH-1_data_20250916')">
                Real Data - 23.5 Hours
                <div style="font-size: 0.8em; opacity: 0.8;">Actual sensor data from Sept 16</div>
            </button>
            <button class="upload-btn" onclick="loadPresetDataset('SCH1_Since915')">
                Real Data - 4 Days
                <div style="font-size: 0.8em; opacity: 0.8;">Extended dataset from Sept 15-19</div>
            </button>
            <button class="upload-btn" onclick="loadPresetDataset('database')" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white;">
                ðŸ“Š Latest from Database
                <div style="font-size: 0.8em; opacity: 0.9;">Live data from TimescaleDB (last 24hrs)</div>
            </button>
        </div>
    </div>


    <!-- Tour highlight overlay -->
    <div id="tourHighlight" class="tour-highlight"></div>

</body>
</html>