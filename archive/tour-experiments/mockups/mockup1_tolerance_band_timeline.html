<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ODCV Analytics - Tolerance Band Timeline</title>
    <style>
        :root {
            --primary: #2563eb;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --background: #f8fafc;
            --surface: #ffffff;
            --text: #1e293b;
            --text-secondary: #64748b;
            --border: #e2e8f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--background);
            color: var(--text);
            line-height: 1.6;
        }

        .header {
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            padding: 1.5rem 2rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .header .subtitle {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .controls {
            background: var(--surface);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .control-group {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .control-item label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .control-item select,
        .control-item input {
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.875rem;
            background: var(--surface);
        }

        .legend {
            display: flex;
            gap: 2rem;
            margin-left: auto;
            align-items: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .legend-box {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .zone-panel {
            background: var(--surface);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .zone-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .zone-title {
            font-size: 1.125rem;
            font-weight: 600;
        }

        .zone-status {
            display: flex;
            gap: 1rem;
            font-size: 0.875rem;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 1rem;
            background: linear-gradient(180deg, #f8fafc 0%, #ffffff 100%);
            border-radius: 4px;
            padding: 1rem;
        }

        .chart-svg {
            width: 100%;
            height: 100%;
        }

        .metric-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .metric-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            background: var(--surface);
            border-radius: 6px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .metric-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .metric-btn:hover:not(.active) {
            background: var(--background);
        }

        .tooltip {
            position: absolute;
            background: var(--text);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            font-size: 0.75rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        .tooltip.visible {
            opacity: 0.95;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .stat-card {
            background: var(--background);
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .stat-change {
            font-size: 0.875rem;
            margin-top: 0.25rem;
        }

        .stat-change.positive {
            color: var(--success);
        }

        .stat-change.negative {
            color: var(--danger);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ODCV Analytics - Tolerance Band Timeline</h1>
        <div class="subtitle">Signal-Response Analysis with Adequacy Tolerance Bands (0.8-1.2x Expected)</div>
    </div>

    <div class="container">
        <div class="controls">
            <div class="control-group">
                <div class="control-item">
                    <label>Date Range</label>
                    <select id="dateRange">
                        <option value="day">Last 24 Hours</option>
                        <option value="week">Last 7 Days</option>
                        <option value="month" selected>September 2025</option>
                    </select>
                </div>
                <div class="control-item">
                    <label>Time Resolution</label>
                    <select id="resolution">
                        <option value="5min">5 Minutes</option>
                        <option value="15min" selected>15 Minutes</option>
                        <option value="hour">Hourly</option>
                    </select>
                </div>
                <div class="control-item">
                    <label>Business Hours Only</label>
                    <input type="checkbox" id="businessHours" checked>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-box" style="background: var(--success);"></div>
                        <span>Adequate (0.8-1.2x)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box" style="background: var(--warning);"></div>
                        <span>Marginal</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-box" style="background: var(--danger);"></div>
                        <span>Inadequate/Excessive</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="zonesContainer"></div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Generate realistic AHU data with signal-response patterns
        class AHUDataGenerator {
            constructor(zoneId) {
                this.zoneId = zoneId;
                this.baseCapacity = {
                    'AHU-1': { maxPeople: 50, maxCFM: 5000, maxDamper: 100 },
                    'AHU-2': { maxPeople: 75, maxCFM: 7500, maxDamper: 100 },
                    'AHU-3': { maxPeople: 30, maxCFM: 3000, maxDamper: 100 }
                }[zoneId];
            }

            generateMonth() {
                const data = [];
                const startDate = new Date('2025-09-01T00:00:00');
                const endDate = new Date('2025-09-30T23:59:59');

                for (let date = new Date(startDate); date <= endDate; date.setMinutes(date.getMinutes() + 15)) {
                    const hour = date.getHours();
                    const dayOfWeek = date.getDay();
                    const isBusinessHours = dayOfWeek !== 0 && dayOfWeek !== 6 && hour >= 8 && hour < 18;

                    // Generate people count based on time of day
                    let peopleCount = 0;
                    if (isBusinessHours) {
                        const baseOccupancy = this.baseCapacity.maxPeople * 0.6;
                        const variation = Math.sin((hour - 8) * Math.PI / 10) * this.baseCapacity.maxPeople * 0.3;
                        peopleCount = Math.max(0, Math.floor(baseOccupancy + variation + (Math.random() - 0.5) * 10));
                    } else if (hour >= 6 && hour < 20) {
                        peopleCount = Math.floor(Math.random() * this.baseCapacity.maxPeople * 0.1);
                    }

                    // Calculate expected responses
                    const expectedCFM = peopleCount * 20; // 20 CFM per person standard
                    const expectedDamper = Math.min(100, (peopleCount / this.baseCapacity.maxPeople) * 100);
                    const expectedTemp = 72 - (peopleCount / this.baseCapacity.maxPeople) * 2; // Cooling with occupancy

                    // Generate actual responses with varying adequacy
                    const responseAdequacy = this.getResponseAdequacy(hour, dayOfWeek);
                    const actualCFM = expectedCFM * responseAdequacy.cfm + (Math.random() - 0.5) * 100;
                    const actualDamper = expectedDamper * responseAdequacy.damper + (Math.random() - 0.5) * 5;
                    const actualTemp = expectedTemp + (1 - responseAdequacy.temp) * 3 + (Math.random() - 0.5);

                    data.push({
                        timestamp: new Date(date),
                        peopleCount,
                        expected: { cfm: expectedCFM, damper: expectedDamper, temp: expectedTemp },
                        actual: {
                            cfm: Math.max(0, actualCFM),
                            damper: Math.max(0, Math.min(100, actualDamper)),
                            temp: actualTemp
                        },
                        adequacy: this.calculateAdequacy(actualCFM, expectedCFM, actualDamper, expectedDamper)
                    });
                }

                return data;
            }

            getResponseAdequacy(hour, dayOfWeek) {
                // Simulate different response patterns
                if (this.zoneId === 'AHU-1') {
                    // Generally adequate with morning lag
                    return {
                        cfm: hour < 10 ? 0.75 : 0.95,
                        damper: hour < 10 ? 0.7 : 1.0,
                        temp: 0.9
                    };
                } else if (this.zoneId === 'AHU-2') {
                    // Overresponsive system
                    return {
                        cfm: 1.3,
                        damper: 1.25,
                        temp: 1.1
                    };
                } else {
                    // Underresponsive during peak
                    return {
                        cfm: hour >= 12 && hour < 14 ? 0.6 : 0.85,
                        damper: hour >= 12 && hour < 14 ? 0.65 : 0.9,
                        temp: 0.8
                    };
                }
            }

            calculateAdequacy(actualCFM, expectedCFM, actualDamper, expectedDamper) {
                if (expectedCFM === 0) return 'adequate';

                const cfmRatio = actualCFM / expectedCFM;
                const damperRatio = actualDamper / expectedDamper;

                if (cfmRatio >= 0.8 && cfmRatio <= 1.2 && damperRatio >= 0.8 && damperRatio <= 1.2) {
                    return 'adequate';
                } else if (cfmRatio >= 0.7 && cfmRatio <= 1.3) {
                    return 'marginal';
                } else {
                    return 'inadequate';
                }
            }
        }

        // Visualization controller
        class ToleranceBandTimeline {
            constructor() {
                this.zones = ['AHU-1', 'AHU-2', 'AHU-3'];
                this.data = {};
                this.selectedMetric = 'cfm';
                this.init();
            }

            init() {
                // Generate data for each zone
                this.zones.forEach(zone => {
                    const generator = new AHUDataGenerator(zone);
                    this.data[zone] = generator.generateMonth();
                });

                this.renderZones();
                this.attachEventListeners();
            }

            renderZones() {
                const container = document.getElementById('zonesContainer');
                container.innerHTML = '';

                this.zones.forEach(zone => {
                    const panel = this.createZonePanel(zone);
                    container.appendChild(panel);
                });
            }

            createZonePanel(zoneId) {
                const panel = document.createElement('div');
                panel.className = 'zone-panel';

                const zoneData = this.data[zoneId];
                const latestData = zoneData[zoneData.length - 1];
                const adequacyStats = this.calculateAdequacyStats(zoneData);

                panel.innerHTML = `
                    <div class="zone-header">
                        <div class="zone-title">${zoneId} - Zone Control Analysis</div>
                        <div class="zone-status">
                            <div class="status-item">
                                <div class="status-indicator" style="background: var(--success);"></div>
                                <span>Current: ${latestData.peopleCount} people</span>
                            </div>
                            <div class="status-item">
                                <span>Adequacy: ${(adequacyStats.adequate * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>

                    <div class="metric-selector">
                        <button class="metric-btn ${this.selectedMetric === 'cfm' ? 'active' : ''}" data-zone="${zoneId}" data-metric="cfm">
                            OA CFM
                        </button>
                        <button class="metric-btn ${this.selectedMetric === 'damper' ? 'active' : ''}" data-zone="${zoneId}" data-metric="damper">
                            Damper %
                        </button>
                        <button class="metric-btn ${this.selectedMetric === 'temp' ? 'active' : ''}" data-zone="${zoneId}" data-metric="temp">
                            Temperature
                        </button>
                        <button class="metric-btn ${this.selectedMetric === 'people' ? 'active' : ''}" data-zone="${zoneId}" data-metric="people">
                            People Count
                        </button>
                    </div>

                    <div class="chart-container" id="chart-${zoneId}">
                        ${this.renderChart(zoneId, this.selectedMetric)}
                    </div>

                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Adequate Response</div>
                            <div class="stat-value">${(adequacyStats.adequate * 100).toFixed(1)}%</div>
                            <div class="stat-change positive">Target: 80-100%</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Average Deviation</div>
                            <div class="stat-value">${adequacyStats.avgDeviation.toFixed(1)}%</div>
                            <div class="stat-change ${Math.abs(adequacyStats.avgDeviation) <= 20 ? 'positive' : 'negative'}">
                                Target: ±20%
                            </div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Peak Occupancy</div>
                            <div class="stat-value">${adequacyStats.peakOccupancy}</div>
                            <div class="stat-change">People</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Response Lag</div>
                            <div class="stat-value">${adequacyStats.avgLag}</div>
                            <div class="stat-change ${adequacyStats.avgLag <= 5 ? 'positive' : 'negative'}">
                                Minutes
                            </div>
                        </div>
                    </div>
                `;

                return panel;
            }

            renderChart(zoneId, metric) {
                const data = this.filterData(this.data[zoneId]);
                const width = 1200;
                const height = 280;
                const margin = { top: 20, right: 30, bottom: 40, left: 60 };
                const innerWidth = width - margin.left - margin.right;
                const innerHeight = height - margin.top - margin.bottom;

                // Create scales
                const xExtent = [data[0].timestamp, data[data.length - 1].timestamp];
                const yExtent = this.getYExtent(data, metric);

                let svg = `<svg class="chart-svg" viewBox="0 0 ${width} ${height}">`;

                // Add gradient definitions
                svg += `
                    <defs>
                        <linearGradient id="toleranceGradient-${zoneId}" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:var(--success);stop-opacity:0.2" />
                            <stop offset="100%" style="stop-color:var(--success);stop-opacity:0.05" />
                        </linearGradient>
                    </defs>
                `;

                // Draw tolerance bands
                if (metric !== 'people') {
                    const tolerancePath = this.createTolerancePath(data, metric, innerWidth, innerHeight, xExtent, yExtent);
                    svg += `<path d="${tolerancePath}" fill="url(#toleranceGradient-${zoneId})" />`;
                }

                // Draw grid
                for (let i = 0; i <= 5; i++) {
                    const y = margin.top + (innerHeight * i / 5);
                    svg += `<line x1="${margin.left}" y1="${y}" x2="${width - margin.right}" y2="${y}"
                            stroke="var(--border)" stroke-dasharray="2,2" opacity="0.5" />`;

                    const value = yExtent[1] - (yExtent[1] - yExtent[0]) * i / 5;
                    svg += `<text x="${margin.left - 5}" y="${y + 4}" text-anchor="end"
                            font-size="11" fill="var(--text-secondary)">${this.formatValue(value, metric)}</text>`;
                }

                // Draw expected line
                if (metric !== 'people') {
                    const expectedPath = this.createPath(data, metric, 'expected', innerWidth, innerHeight, xExtent, yExtent);
                    svg += `<path d="${expectedPath}" fill="none" stroke="var(--text-secondary)"
                            stroke-width="2" stroke-dasharray="5,3" opacity="0.7" />`;
                }

                // Draw actual line
                const actualPath = metric === 'people'
                    ? this.createPeoplePath(data, innerWidth, innerHeight, xExtent, yExtent)
                    : this.createPath(data, metric, 'actual', innerWidth, innerHeight, xExtent, yExtent);

                const lineColor = metric === 'people' ? 'var(--primary)' : this.getLineColor(data, metric);
                svg += `<path d="${actualPath}" fill="none" stroke="${lineColor}" stroke-width="2" />`;

                // Draw data points
                data.forEach((d, i) => {
                    if (i % 4 === 0) { // Show every 4th point for clarity
                        const x = margin.left + (i / (data.length - 1)) * innerWidth;
                        const y = metric === 'people'
                            ? margin.top + innerHeight - (d.peopleCount / yExtent[1]) * innerHeight
                            : margin.top + innerHeight - ((d.actual[metric] - yExtent[0]) / (yExtent[1] - yExtent[0])) * innerHeight;

                        const color = metric === 'people' ? 'var(--primary)' : this.getPointColor(d, metric);
                        svg += `<circle cx="${x}" cy="${y}" r="3" fill="${color}"
                                class="data-point" data-zone="${zoneId}" data-index="${i}" />`;
                    }
                });

                // Add axis labels
                svg += `<text x="${width / 2}" y="${height - 5}" text-anchor="middle"
                        font-size="12" fill="var(--text-secondary)">Time</text>`;
                svg += `<text x="20" y="${height / 2}" text-anchor="middle"
                        transform="rotate(-90 20 ${height / 2})"
                        font-size="12" fill="var(--text-secondary)">${this.getYLabel(metric)}</text>`;

                svg += '</svg>';
                return svg;
            }

            createTolerancePath(data, metric, width, height, xExtent, yExtent) {
                let path = 'M';

                // Upper tolerance band (1.2x)
                data.forEach((d, i) => {
                    const x = (i / (data.length - 1)) * width;
                    const y = height - ((d.expected[metric] * 1.2 - yExtent[0]) / (yExtent[1] - yExtent[0])) * height;
                    path += `${i === 0 ? '' : 'L'} ${x + 60},${y + 20}`;
                });

                // Lower tolerance band (0.8x)
                for (let i = data.length - 1; i >= 0; i--) {
                    const d = data[i];
                    const x = (i / (data.length - 1)) * width;
                    const y = height - ((d.expected[metric] * 0.8 - yExtent[0]) / (yExtent[1] - yExtent[0])) * height;
                    path += `L ${x + 60},${y + 20}`;
                }

                path += 'Z';
                return path;
            }

            createPath(data, metric, type, width, height, xExtent, yExtent) {
                return data.map((d, i) => {
                    const x = (i / (data.length - 1)) * width + 60;
                    const value = d[type][metric];
                    const y = height - ((value - yExtent[0]) / (yExtent[1] - yExtent[0])) * height + 20;
                    return `${i === 0 ? 'M' : 'L'} ${x},${y}`;
                }).join(' ');
            }

            createPeoplePath(data, width, height, xExtent, yExtent) {
                return data.map((d, i) => {
                    const x = (i / (data.length - 1)) * width + 60;
                    const y = height - (d.peopleCount / yExtent[1]) * height + 20;
                    return `${i === 0 ? 'M' : 'L'} ${x},${y}`;
                }).join(' ');
            }

            getYExtent(data, metric) {
                if (metric === 'people') {
                    return [0, Math.max(...data.map(d => d.peopleCount)) * 1.1];
                } else if (metric === 'temp') {
                    const allValues = data.flatMap(d => [d.expected[metric], d.actual[metric]]);
                    return [Math.min(...allValues) - 2, Math.max(...allValues) + 2];
                } else {
                    const allValues = data.flatMap(d => [
                        d.expected[metric] * 0.8,
                        d.expected[metric] * 1.2,
                        d.actual[metric]
                    ]);
                    return [0, Math.max(...allValues) * 1.1];
                }
            }

            getYLabel(metric) {
                const labels = {
                    cfm: 'Outside Air CFM',
                    damper: 'Damper Position (%)',
                    temp: 'Temperature (°F)',
                    people: 'People Count'
                };
                return labels[metric];
            }

            formatValue(value, metric) {
                if (metric === 'cfm') return Math.round(value);
                if (metric === 'damper') return `${Math.round(value)}%`;
                if (metric === 'temp') return `${value.toFixed(1)}°F`;
                if (metric === 'people') return Math.round(value);
                return value.toFixed(1);
            }

            getLineColor(data, metric) {
                const adequacyCount = data.reduce((acc, d) => {
                    if (!d.expected[metric]) return acc;
                    const ratio = d.actual[metric] / d.expected[metric];
                    if (ratio >= 0.8 && ratio <= 1.2) acc.adequate++;
                    else if (ratio >= 0.7 && ratio <= 1.3) acc.marginal++;
                    else acc.inadequate++;
                    return acc;
                }, { adequate: 0, marginal: 0, inadequate: 0 });

                const total = adequacyCount.adequate + adequacyCount.marginal + adequacyCount.inadequate;
                if (adequacyCount.adequate / total > 0.8) return 'var(--success)';
                if (adequacyCount.adequate / total > 0.6) return 'var(--warning)';
                return 'var(--danger)';
            }

            getPointColor(dataPoint, metric) {
                if (!dataPoint.expected[metric]) return 'var(--text-secondary)';
                const ratio = dataPoint.actual[metric] / dataPoint.expected[metric];
                if (ratio >= 0.8 && ratio <= 1.2) return 'var(--success)';
                if (ratio >= 0.7 && ratio <= 1.3) return 'var(--warning)';
                return 'var(--danger)';
            }

            filterData(data) {
                const businessHours = document.getElementById('businessHours').checked;
                const dateRange = document.getElementById('dateRange').value;
                const resolution = document.getElementById('resolution').value;

                let filtered = data;

                if (businessHours) {
                    filtered = filtered.filter(d => {
                        const hour = d.timestamp.getHours();
                        const day = d.timestamp.getDay();
                        return day !== 0 && day !== 6 && hour >= 8 && hour < 18;
                    });
                }

                if (dateRange === 'day') {
                    const cutoff = new Date('2025-09-30T00:00:00');
                    filtered = filtered.filter(d => d.timestamp >= cutoff);
                } else if (dateRange === 'week') {
                    const cutoff = new Date('2025-09-23T00:00:00');
                    filtered = filtered.filter(d => d.timestamp >= cutoff);
                }

                // Sample based on resolution
                const sampling = { '5min': 1, '15min': 3, 'hour': 12 }[resolution];
                return filtered.filter((_, i) => i % sampling === 0);
            }

            calculateAdequacyStats(data) {
                const businessHoursData = data.filter(d => {
                    const hour = d.timestamp.getHours();
                    const day = d.timestamp.getDay();
                    return day !== 0 && day !== 6 && hour >= 8 && hour < 18;
                });

                let adequateCount = 0;
                let totalDeviation = 0;
                let count = 0;

                businessHoursData.forEach(d => {
                    if (d.expected.cfm > 0) {
                        const ratio = d.actual.cfm / d.expected.cfm;
                        if (ratio >= 0.8 && ratio <= 1.2) adequateCount++;
                        totalDeviation += (ratio - 1) * 100;
                        count++;
                    }
                });

                return {
                    adequate: count > 0 ? adequateCount / count : 0,
                    avgDeviation: count > 0 ? totalDeviation / count : 0,
                    peakOccupancy: Math.max(...data.map(d => d.peopleCount)),
                    avgLag: Math.floor(Math.random() * 10 + 3) // Simulated lag
                };
            }

            attachEventListeners() {
                // Metric selection
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('metric-btn')) {
                        const zone = e.target.dataset.zone;
                        const metric = e.target.dataset.metric;

                        // Update active state
                        e.target.parentElement.querySelectorAll('.metric-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        e.target.classList.add('active');

                        // Re-render chart
                        const chartContainer = document.getElementById(`chart-${zone}`);
                        chartContainer.innerHTML = this.renderChart(zone, metric);
                    }
                });

                // Control changes
                ['dateRange', 'resolution', 'businessHours'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => {
                        this.renderZones();
                    });
                });

                // Hover tooltips
                document.addEventListener('mouseover', (e) => {
                    if (e.target.classList.contains('data-point')) {
                        const zone = e.target.dataset.zone;
                        const index = parseInt(e.target.dataset.index);
                        const dataPoint = this.data[zone][index];

                        const tooltip = document.getElementById('tooltip');
                        tooltip.innerHTML = `
                            <div><strong>${dataPoint.timestamp.toLocaleString()}</strong></div>
                            <div>People: ${dataPoint.peopleCount}</div>
                            <div>CFM: ${Math.round(dataPoint.actual.cfm)} / ${Math.round(dataPoint.expected.cfm)}</div>
                            <div>Damper: ${dataPoint.actual.damper.toFixed(1)}% / ${dataPoint.expected.damper.toFixed(1)}%</div>
                            <div>Temp: ${dataPoint.actual.temp.toFixed(1)}°F / ${dataPoint.expected.temp.toFixed(1)}°F</div>
                        `;

                        tooltip.style.left = e.pageX + 10 + 'px';
                        tooltip.style.top = e.pageY - 50 + 'px';
                        tooltip.classList.add('visible');
                    }
                });

                document.addEventListener('mouseout', (e) => {
                    if (e.target.classList.contains('data-point')) {
                        document.getElementById('tooltip').classList.remove('visible');
                    }
                });
            }
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            new ToleranceBandTimeline();
        });
    </script>
</body>
</html>