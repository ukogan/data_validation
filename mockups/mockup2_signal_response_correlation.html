<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ODCV Analytics - Signal-Response Correlation View</title>
    <style>
        :root {
            --primary: #3b82f6;
            --secondary: #8b5cf6;
            --success: #22c55e;
            --warning: #f97316;
            --danger: #dc2626;
            --dark: #0f172a;
            --light: #f1f5f9;
            --surface: #ffffff;
            --border: #e2e8f0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            color: var(--dark);
        }

        .header {
            background: var(--surface);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            padding: 1.5rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-stats {
            display: flex;
            gap: 2rem;
        }

        .header-stat {
            text-align: center;
        }

        .header-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .header-stat-label {
            font-size: 0.75rem;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
        }

        .controls {
            background: var(--surface);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .control-row {
            display: flex;
            gap: 2rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #475569;
        }

        .control-group select,
        .control-group input {
            padding: 0.625rem 0.875rem;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 0.875rem;
            background: var(--surface);
            transition: border-color 0.2s;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .zone-correlation {
            background: var(--surface);
            border-radius: 12px;
            margin-bottom: 2rem;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .zone-header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .zone-title {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .zone-metrics {
            display: flex;
            gap: 2rem;
        }

        .zone-metric {
            text-align: center;
        }

        .zone-metric-value {
            font-size: 1.25rem;
            font-weight: 700;
        }

        .zone-metric-label {
            font-size: 0.75rem;
            opacity: 0.9;
        }

        .signal-panel {
            padding: 1.5rem;
            background: #fafbfc;
            border-bottom: 2px solid var(--border);
        }

        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .signal-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--dark);
        }

        .signal-stats {
            display: flex;
            gap: 1rem;
        }

        .signal-stat {
            padding: 0.25rem 0.75rem;
            background: var(--surface);
            border-radius: 20px;
            font-size: 0.75rem;
            border: 1px solid var(--border);
        }

        .chart-container {
            position: relative;
            height: 150px;
            background: var(--surface);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.5rem;
        }

        .response-panel {
            padding: 1.5rem;
        }

        .response-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .response-card {
            background: #fafbfc;
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .response-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .response-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .response-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--dark);
        }

        .adequacy-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .adequacy-badge.adequate {
            background: var(--success);
            color: white;
        }

        .adequacy-badge.marginal {
            background: var(--warning);
            color: white;
        }

        .adequacy-badge.inadequate {
            background: var(--danger);
            color: white;
        }

        .response-chart {
            height: 100px;
            position: relative;
            margin-bottom: 1rem;
        }

        .response-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .response-stat {
            font-size: 0.75rem;
        }

        .response-stat-label {
            color: #64748b;
        }

        .response-stat-value {
            font-weight: 600;
            color: var(--dark);
        }

        .correlation-matrix {
            background: var(--surface);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .matrix-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--dark);
        }

        .matrix-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        .matrix-cell {
            aspect-ratio: 1;
            background: #fafbfc;
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            border: 2px solid var(--border);
            transition: all 0.3s;
        }

        .matrix-cell:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
        }

        .matrix-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .matrix-label {
            font-size: 0.75rem;
            color: #64748b;
        }

        .lag-indicator {
            display: inline-block;
            width: 60px;
            height: 24px;
            background: var(--light);
            border-radius: 12px;
            position: relative;
            overflow: hidden;
        }

        .lag-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transition: width 0.3s;
        }

        .lag-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.625rem;
            font-weight: 600;
            color: white;
            z-index: 1;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1>Signal-Response Correlation Analysis</h1>
            <div class="header-stats">
                <div class="header-stat">
                    <div class="header-stat-value">3</div>
                    <div class="header-stat-label">Active Zones</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-value">87.3%</div>
                    <div class="header-stat-label">Avg Adequacy</div>
                </div>
                <div class="header-stat">
                    <div class="header-stat-value">4.2min</div>
                    <div class="header-stat-label">Avg Lag</div>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label>Analysis Period</label>
                    <select id="period">
                        <option value="hour">Last Hour</option>
                        <option value="day" selected>Last 24 Hours</option>
                        <option value="week">Last Week</option>
                        <option value="month">September 2025</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Zone Filter</label>
                    <select id="zoneFilter">
                        <option value="all">All Zones</option>
                        <option value="AHU-1">AHU-1</option>
                        <option value="AHU-2">AHU-2</option>
                        <option value="AHU-3">AHU-3</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Lag Analysis</label>
                    <input type="checkbox" id="lagAnalysis" checked>
                </div>
                <div class="control-group">
                    <label>Show Correlation</label>
                    <input type="checkbox" id="showCorrelation" checked>
                </div>
                <div class="control-group">
                    <label>Auto-Refresh (30s)</label>
                    <input type="checkbox" id="autoRefresh">
                </div>
            </div>
        </div>

        <div id="zonesContainer"></div>

        <div class="correlation-matrix">
            <div class="matrix-title">Cross-Zone Correlation Analysis</div>
            <div class="matrix-grid" id="correlationMatrix"></div>
        </div>
    </div>

    <script>
        class SignalResponseCorrelation {
            constructor() {
                this.zones = ['AHU-1', 'AHU-2', 'AHU-3'];
                this.metrics = ['cfm', 'damper', 'temp'];
                this.data = {};
                this.charts = {};
                this.init();
            }

            init() {
                this.generateData();
                this.render();
                this.attachEventListeners();
                this.startAutoRefresh();
            }

            generateData() {
                this.zones.forEach(zone => {
                    const maxPeople = zone === 'AHU-2' ? 75 : zone === 'AHU-1' ? 50 : 30;
                    const data = [];

                    const now = new Date('2025-09-30T16:00:00');
                    for (let i = 0; i < 96; i++) { // 24 hours of 15-min intervals
                        const timestamp = new Date(now - i * 15 * 60 * 1000);
                        const hour = timestamp.getHours();
                        const isBusinessHours = hour >= 8 && hour < 18;

                        // Generate occupancy pattern
                        const peopleCount = isBusinessHours
                            ? Math.floor(maxPeople * (0.5 + 0.4 * Math.sin((hour - 8) * Math.PI / 10)))
                            : Math.floor(Math.random() * maxPeople * 0.1);

                        // Calculate expected responses
                        const expectedCFM = peopleCount * 20;
                        const expectedDamper = (peopleCount / maxPeople) * 100;
                        const expectedTemp = 72 - (peopleCount / maxPeople) * 2;

                        // Generate actual responses with lag
                        const lag = Math.floor(Math.random() * 8 + 2); // 2-10 minutes lag
                        const adequacyFactor = this.getAdequacyFactor(zone, hour);

                        data.push({
                            timestamp,
                            peopleCount,
                            lag,
                            expected: {
                                cfm: expectedCFM,
                                damper: expectedDamper,
                                temp: expectedTemp
                            },
                            actual: {
                                cfm: expectedCFM * adequacyFactor.cfm + (Math.random() - 0.5) * 200,
                                damper: Math.min(100, Math.max(0, expectedDamper * adequacyFactor.damper + (Math.random() - 0.5) * 10)),
                                temp: expectedTemp + (1 - adequacyFactor.temp) * 2 + (Math.random() - 0.5)
                            },
                            correlation: this.calculateCorrelation(peopleCount, expectedCFM, maxPeople)
                        });
                    }

                    this.data[zone] = data.reverse();
                });
            }

            getAdequacyFactor(zone, hour) {
                if (zone === 'AHU-1') {
                    return { cfm: 0.95, damper: 0.92, temp: 0.98 };
                } else if (zone === 'AHU-2') {
                    return hour >= 12 && hour < 14
                        ? { cfm: 0.7, damper: 0.65, temp: 0.75 }
                        : { cfm: 0.88, damper: 0.85, temp: 0.9 };
                } else {
                    return { cfm: 1.15, damper: 1.2, temp: 1.05 };
                }
            }

            calculateCorrelation(peopleCount, expectedCFM, maxPeople) {
                const correlation = peopleCount / maxPeople;
                return {
                    strength: correlation,
                    lag: Math.floor(Math.random() * 10 + 2),
                    confidence: 0.85 + Math.random() * 0.15
                };
            }

            render() {
                this.renderZones();
                this.renderCorrelationMatrix();
            }

            renderZones() {
                const container = document.getElementById('zonesContainer');
                container.innerHTML = '';

                const zoneFilter = document.getElementById('zoneFilter').value;
                const zonesToRender = zoneFilter === 'all' ? this.zones : [zoneFilter];

                zonesToRender.forEach(zone => {
                    const panel = this.createZonePanel(zone);
                    container.appendChild(panel);
                });
            }

            createZonePanel(zone) {
                const panel = document.createElement('div');
                panel.className = 'zone-correlation';

                const zoneData = this.getFilteredData(zone);
                const latestData = zoneData[zoneData.length - 1];
                const stats = this.calculateZoneStats(zoneData);

                panel.innerHTML = `
                    <div class="zone-header">
                        <div class="zone-title">${zone}</div>
                        <div class="zone-metrics">
                            <div class="zone-metric">
                                <div class="zone-metric-value">${latestData.peopleCount}</div>
                                <div class="zone-metric-label">Current Occupancy</div>
                            </div>
                            <div class="zone-metric">
                                <div class="zone-metric-value">${stats.avgAdequacy.toFixed(1)}%</div>
                                <div class="zone-metric-label">Response Adequacy</div>
                            </div>
                            <div class="zone-metric">
                                <div class="zone-metric-value">${stats.avgLag.toFixed(1)}min</div>
                                <div class="zone-metric-label">Avg Response Lag</div>
                            </div>
                        </div>
                    </div>

                    <div class="signal-panel">
                        <div class="signal-header">
                            <div class="signal-title">People Count Signal</div>
                            <div class="signal-stats">
                                <div class="signal-stat">Peak: ${stats.peakOccupancy} people</div>
                                <div class="signal-stat">Avg: ${stats.avgOccupancy.toFixed(0)} people</div>
                                <div class="signal-stat">Utilization: ${stats.utilization.toFixed(1)}%</div>
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="signal-${zone}"></canvas>
                        </div>
                    </div>

                    <div class="response-panel">
                        <div class="response-grid">
                            ${this.metrics.map(metric => this.createResponseCard(zone, metric, zoneData)).join('')}
                        </div>
                    </div>
                `;

                // Render signal chart after DOM update
                setTimeout(() => {
                    this.renderSignalChart(zone, zoneData);
                    this.metrics.forEach(metric => {
                        this.renderResponseChart(zone, metric, zoneData);
                    });
                }, 0);

                return panel;
            }

            createResponseCard(zone, metric, data) {
                const stats = this.calculateMetricStats(data, metric);
                const adequacy = this.getAdequacyLevel(stats.avgRatio);
                const metricLabels = {
                    cfm: 'Outside Air CFM',
                    damper: 'Damper Position',
                    temp: 'Zone Temperature'
                };

                return `
                    <div class="response-card">
                        <div class="response-header">
                            <div class="response-title">${metricLabels[metric]}</div>
                            <div class="adequacy-badge ${adequacy}">${adequacy}</div>
                        </div>
                        <div class="response-chart">
                            <canvas id="response-${zone}-${metric}"></canvas>
                        </div>
                        <div class="response-stats">
                            <div class="response-stat">
                                <div class="response-stat-label">Current</div>
                                <div class="response-stat-value">${this.formatMetricValue(data[data.length - 1].actual[metric], metric)}</div>
                            </div>
                            <div class="response-stat">
                                <div class="response-stat-label">Expected</div>
                                <div class="response-stat-value">${this.formatMetricValue(data[data.length - 1].expected[metric], metric)}</div>
                            </div>
                            <div class="response-stat">
                                <div class="response-stat-label">Avg Ratio</div>
                                <div class="response-stat-value">${stats.avgRatio.toFixed(2)}x</div>
                            </div>
                            <div class="response-stat">
                                <div class="response-stat-label">Response Lag</div>
                                <div class="response-stat-value">
                                    <div class="lag-indicator">
                                        <div class="lag-bar" style="width: ${Math.min(100, stats.avgLag * 10)}%"></div>
                                        <div class="lag-text">${stats.avgLag.toFixed(0)}min</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            renderSignalChart(zone, data) {
                const canvas = document.getElementById(`signal-${zone}`);
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;

                const padding = { top: 10, right: 10, bottom: 20, left: 40 };
                const width = canvas.width - padding.left - padding.right;
                const height = canvas.height - padding.top - padding.bottom;

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw grid
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = padding.top + (height * i / 4);
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(canvas.width - padding.right, y);
                    ctx.stroke();
                }

                // Draw people count line
                const maxPeople = Math.max(...data.map(d => d.peopleCount));
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.beginPath();

                data.forEach((d, i) => {
                    const x = padding.left + (i / (data.length - 1)) * width;
                    const y = padding.top + height - (d.peopleCount / maxPeople) * height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });

                ctx.stroke();

                // Draw area fill
                ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                ctx.lineTo(canvas.width - padding.right, canvas.height - padding.bottom);
                ctx.lineTo(padding.left, canvas.height - padding.bottom);
                ctx.closePath();
                ctx.fill();

                // Draw axis labels
                ctx.fillStyle = '#64748b';
                ctx.font = '10px Inter';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 4; i++) {
                    const value = Math.round(maxPeople * (1 - i / 4));
                    const y = padding.top + (height * i / 4);
                    ctx.fillText(value.toString(), padding.left - 5, y + 3);
                }
            }

            renderResponseChart(zone, metric, data) {
                const canvas = document.getElementById(`response-${zone}-${metric}`);
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;

                const padding = { top: 10, right: 10, bottom: 10, left: 10 };
                const width = canvas.width - padding.left - padding.right;
                const height = canvas.height - padding.top - padding.bottom;

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Calculate max value
                const values = data.flatMap(d => [d.expected[metric], d.actual[metric]]);
                const maxValue = Math.max(...values) * 1.1;

                // Draw tolerance band
                ctx.fillStyle = 'rgba(34, 197, 94, 0.1)';
                ctx.beginPath();
                data.forEach((d, i) => {
                    const x = padding.left + (i / (data.length - 1)) * width;
                    const yUpper = padding.top + height - (d.expected[metric] * 1.2 / maxValue) * height;
                    if (i === 0) ctx.moveTo(x, yUpper);
                    else ctx.lineTo(x, yUpper);
                });
                for (let i = data.length - 1; i >= 0; i--) {
                    const d = data[i];
                    const x = padding.left + (i / (data.length - 1)) * width;
                    const yLower = padding.top + height - (d.expected[metric] * 0.8 / maxValue) * height;
                    ctx.lineTo(x, yLower);
                }
                ctx.closePath();
                ctx.fill();

                // Draw expected line
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                data.forEach((d, i) => {
                    const x = padding.left + (i / (data.length - 1)) * width;
                    const y = padding.top + height - (d.expected[metric] / maxValue) * height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw actual line
                const adequacy = this.calculateMetricStats(data, metric).avgRatio;
                ctx.strokeStyle = adequacy >= 0.8 && adequacy <= 1.2 ? '#22c55e' : adequacy >= 0.7 && adequacy <= 1.3 ? '#f97316' : '#dc2626';
                ctx.lineWidth = 2;
                ctx.beginPath();
                data.forEach((d, i) => {
                    const x = padding.left + (i / (data.length - 1)) * width;
                    const y = padding.top + height - (d.actual[metric] / maxValue) * height;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw lag indicators
                if (document.getElementById('lagAnalysis').checked) {
                    ctx.fillStyle = 'rgba(139, 92, 246, 0.3)';
                    data.forEach((d, i) => {
                        if (i % 8 === 0 && d.lag > 5) {
                            const x = padding.left + (i / (data.length - 1)) * width;
                            const width = (d.lag / 15) * 20; // Scale lag to pixel width
                            ctx.fillRect(x, padding.top, width, height);
                        }
                    });
                }
            }

            renderCorrelationMatrix() {
                const container = document.getElementById('correlationMatrix');
                const correlations = this.calculateCrossZoneCorrelations();

                container.innerHTML = correlations.map(corr => `
                    <div class="matrix-cell" style="border-color: ${this.getCorrelationColor(corr.value)}">
                        <div class="matrix-value" style="color: ${this.getCorrelationColor(corr.value)}">
                            ${corr.value.toFixed(2)}
                        </div>
                        <div class="matrix-label">${corr.from} → ${corr.to}</div>
                    </div>
                `).join('');
            }

            calculateCrossZoneCorrelations() {
                const correlations = [];
                this.zones.forEach(from => {
                    this.zones.forEach(to => {
                        if (from !== to) {
                            const correlation = this.calculateZoneCorrelation(from, to);
                            correlations.push({ from, to, value: correlation });
                        }
                    });
                });
                return correlations.slice(0, 12); // Limit to 12 for 4x3 grid
            }

            calculateZoneCorrelation(zone1, zone2) {
                // Simplified correlation calculation
                const data1 = this.data[zone1].map(d => d.peopleCount);
                const data2 = this.data[zone2].map(d => d.peopleCount);

                const avg1 = data1.reduce((a, b) => a + b, 0) / data1.length;
                const avg2 = data2.reduce((a, b) => a + b, 0) / data2.length;

                let correlation = 0;
                for (let i = 0; i < data1.length; i++) {
                    correlation += (data1[i] - avg1) * (data2[i] - avg2);
                }

                return Math.abs(correlation) / (data1.length * Math.sqrt(avg1 * avg2)) * (0.5 + Math.random() * 0.5);
            }

            getCorrelationColor(value) {
                if (value > 0.8) return '#22c55e';
                if (value > 0.5) return '#f97316';
                return '#dc2626';
            }

            getFilteredData(zone) {
                const period = document.getElementById('period').value;
                let data = this.data[zone];

                const periodMap = {
                    hour: 4,
                    day: 96,
                    week: 672,
                    month: 2880
                };

                return data.slice(-periodMap[period] || 96);
            }

            calculateZoneStats(data) {
                const businessHoursData = data.filter(d => {
                    const hour = d.timestamp.getHours();
                    return hour >= 8 && hour < 18;
                });

                const occupancies = businessHoursData.map(d => d.peopleCount);
                const lags = businessHoursData.map(d => d.lag);

                let totalAdequacy = 0;
                let count = 0;

                businessHoursData.forEach(d => {
                    if (d.expected.cfm > 0) {
                        const ratio = d.actual.cfm / d.expected.cfm;
                        if (ratio >= 0.8 && ratio <= 1.2) totalAdequacy++;
                        count++;
                    }
                });

                return {
                    peakOccupancy: Math.max(...occupancies),
                    avgOccupancy: occupancies.reduce((a, b) => a + b, 0) / occupancies.length,
                    utilization: (Math.max(...occupancies) / 75) * 100, // Assuming max capacity of 75
                    avgAdequacy: count > 0 ? (totalAdequacy / count) * 100 : 0,
                    avgLag: lags.reduce((a, b) => a + b, 0) / lags.length
                };
            }

            calculateMetricStats(data, metric) {
                const ratios = [];
                const lags = [];

                data.forEach(d => {
                    if (d.expected[metric] > 0) {
                        ratios.push(d.actual[metric] / d.expected[metric]);
                        lags.push(d.lag);
                    }
                });

                return {
                    avgRatio: ratios.length > 0 ? ratios.reduce((a, b) => a + b, 0) / ratios.length : 1,
                    avgLag: lags.length > 0 ? lags.reduce((a, b) => a + b, 0) / lags.length : 0
                };
            }

            getAdequacyLevel(ratio) {
                if (ratio >= 0.8 && ratio <= 1.2) return 'adequate';
                if (ratio >= 0.7 && ratio <= 1.3) return 'marginal';
                return 'inadequate';
            }

            formatMetricValue(value, metric) {
                if (metric === 'cfm') return `${Math.round(value)} CFM`;
                if (metric === 'damper') return `${value.toFixed(1)}%`;
                if (metric === 'temp') return `${value.toFixed(1)}°F`;
                return value.toFixed(1);
            }

            attachEventListeners() {
                ['period', 'zoneFilter', 'lagAnalysis', 'showCorrelation'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => this.render());
                });
            }

            startAutoRefresh() {
                setInterval(() => {
                    if (document.getElementById('autoRefresh').checked) {
                        this.generateData();
                        this.render();
                    }
                }, 30000);
            }
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            new SignalResponseCorrelation();
        });
    </script>
</body>
</html>